---
author: QuinnRadich
Description: Windows 10 build 10240 and updates to developer tools continue to provide the tools, features, and experiences powered by the Universal Windows Platform.
title: Nouveautés de Windows 10, build 10240 - juillet 2015
keywords: nouveautés, nouveauté, mise à jour, mises à jour, fonctionnalités, nouveau, Windows10, 1507, 10240
ms.author: quradic
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: c38fe989bd854d44bb7dc3c0cba36a4ae145854c
ms.sourcegitcommit: 93c0a60cf531c7d9fe7b00e7cf78df86906f9d6e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/22/2018
ms.locfileid: "7578053"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Nouveautés pour les développeurs dans Windows 10, build 10240

Windows10, build10240 et le SDK mis à jour offrent les outils, fonctionnalités et expériences pour créer de remarquables applications sur la plateforme Windows universelle. Après avoir [installé les outils et le Kit de développement logiciel](http://go.microsoft.com/fwlink/?LinkId=821431) sur Windows10, vous êtes prêt à [créer une nouvelle application Windows universelle](../get-started/create-uwp-apps.md) ou à découvrir comment utiliser votre [code d’application existant sur Windows](../porting/index.md).

Voici un aperçu fonction par fonction Nouveautés pour vous dans Windows 10, build 10240 (également appelé Windows 10 version 1507).

## <a name="adaptive-layouts"></a>Dispositions adaptatives

Fonctionnalité | Description
 :---- | ----:
Plusieurs affichages pour un contenu personnalisé | XAML fournit une nouvelle prise en charge pour la définition d’affichages personnalisés (fichiers .xaml) qui partagent le même fichier de code. Vous pouvez ainsi créer et gérer plus facilement différents affichages personnalisés pour une famille d’appareils ou un scénario spécifique. Si votre application inclut divers contenus, disposition ou modèles de navigation d’interface utilisateur qui sont complètement différents d’autres scénarios, créez plusieurs affichages. Par exemple, vous pouvez utiliser un contrôle [Pivot](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.pivot.aspx) avec une navigation optimisée pour l’utilisation d’une seule main dans votre application mobile et un contrôle [SplitView](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.splitview.aspx) avec un menu de navigation optimisé pour la souris dans votre application de bureau.
StateTriggers | Grâce à la nouvelle fonctionnalité [VisualState.StateTriggers](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.statetriggers.aspx), vous pouvez définir des propriétés de manière conditionnelle en fonction de la hauteur/largeur de la fenêtre ou d’un déclencheur personnalisé. Auparavant, vous deviez gérer les événements de fenêtre [SizeChanged](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.window.sizechanged.aspx) dans le code et appeler [VisualStateManager.GotoState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.gotostate.aspx).
Setters | Grâce à la nouvelle syntaxe [VisualState.Setters](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.setters.aspx), vous pouvez utiliser un marquage simplifié pour définir des changements de propriété dans [VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx). Auparavant, vous deviez utiliser une table de montage et créer des animations pour appliquer des changements de propriétés tels que le changement d’orientation d’un [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx) de Horizontal à Vertical. Dans les applicationsWindows universelles, vous pouvez utiliser cette syntaxeSetter plus simple: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>FonctionnalitésXAML

Fonctionnalité | Description
 :---- | :----
Liaisons de données compilées (x:Bind) | Dans les applications Windows universelles, vous pouvez utiliser le nouveau mécanisme de liaison basé sur un compilateur activé par la propriété x:Bind. Les liaisons basées sur un compilateur sont fortement typées et traitées au moment de la compilation, étant ainsi plus rapides et renvoyant des erreurs de compilation lorsque les types de liaison ne correspondent pas. Les liaisons étant converties en code d’application compilé, vous pouvez désormais les déboguer en parcourant le code dans Visual Studio afin de diagnostiquer des problèmes de liaison spécifiques. Vous pouvez également utiliser x:Bind pour lier une méthode telle que: <textblock text="{x:Bind Customer.Address.ToString()}" /> Dans des scénarios de liaison classiques, vous pouvez utiliser x:Bind à la place de Binding et ainsi améliorer les performances et la maintenabilité.
Rendu incrémentiel déclaratif des listes (x:Phase) | Dans les applications Windows universelles, le nouvel attribut x:Phase vous permet d’effectuer un rendu incrémentiel, ou progressif, des listes à l’aide de XAML au lieu du code. Lorsque vous affichez un panoramique de longues listes d’éléments complexes, votre application peut ne pas être en mesure d’afficher les éléments suffisamment rapidement, d’où une expérience médiocre pour vos utilisateurs. Le rendu progressif vous permet de spécifier la priorité de chaque élément d’une liste de sorte que seuls les éléments importants de la liste soient rendus plus rapidement dans les scénarios de panoramique rapide. L’expérience de panoramique de vos utilisateurs est ainsi plus fluide. <br /><br /> Dans Windows 8.1, vous pouviez gérer l’événement [ContainerContentChanging](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.containercontentchanging.aspx) et écrire du code pour afficher progressivement des éléments de liste. Dans les applications UWP, vous pouvez obtenir un rendu progressif déclaratif grâce à l’attribut x:Phase. Associé aux liaisons compilées x:Bind, x:Phase vous permet de spécifier facilement une priorité de rendu pour chaque élément lié d’un modèle de données. Dans le cas d’un panoramique, le rendu des éléments est fractionné en fonction de la phase, qui permet un rendu incrémentiel des éléments.
Chargement différé d’éléments de l’interface utilisateur (x:deferLoadstrategy) | Dans les applications Windows universelles, la nouvelle directive x:deferLoadstrategy permet de spécifier des éléments de votre interface utilisateur à charger en différé, ce qui améliore les performances de démarrage et réduit l’utilisation de la mémoire de votre application. Par exemple, si l’interface utilisateur de votre application contient un élément pour la validation des données qui s’affiche uniquement lors de la saisie de données incorrectes, vous pouvez différer le chargement de cet élément jusqu’à ce qu’il soit nécessaire. Ensuite, les objets d’éléments ne sont pas créés au chargement de la page, mais uniquement en cas d’erreur de données et lorsqu’ils sont requis pour l’ajout à l’arborescence visuelle de la page.
SplitView | Le nouveau contrôle [SplitView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.splitview.aspx) vous permet d’afficher et de masquer facilement le contenu temporaire. Il est généralement utilisé dans les scénarios de navigation de niveau supérieur comme le «hamburger menu», dans lequel le contenu de navigation est masqué puis affiché si nécessaire en résultat d’une action de l’utilisateur.
RelativePanel | [RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx) est un nouveau panneau de disposition qui vous permet de positionner et d’aligner des objets enfants les uns par rapport aux autres ou par rapport au panneau parent. Par exemple, vous pouvez spécifier que du texte doit toujours se trouver à gauche du panneau et qu’un bouton doit toujours être aligné sous le texte. Utilisez RelativePanel lors de la création d’interfaces utilisateur sans modèle linéaire précis dans lesquelles vous devriez utiliser [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx) ou [Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx).
CalendarView | Le contrôle [CalendarView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.calendarview.aspx) simplifie l’affichage et la sélection de dates et de plages de dates à l’aide d’un affichage mensuel personnalisable. CalendarView prend en charge des fonctionnalités telles que les dates minimum, maximum et blackout afin de limiter les dates pouvant être sélectionnées. Vous pouvez également définir des barres de densités personnalisées pouvant être utilisées pour afficher «l’exhaustivité» générale de la panification d’un jour donné.
CalendarDatePicker | [CalendarDatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.calendardatepicker.aspx) est un contrôle déroulant optimisé pour la sélection d’une seule date dans un CalendarView, dans lequel les informations contextuelles comme le jour de la semaine ou l’exhaustivité du calendrier sont importantes. Il est similaire au contrôle [DatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepicker.aspx), sauf que DatePicker est optimisé pour la sélection d’une date connue comme une date de naissance.
MediaTransportControls | La nouvelle classe [MediaTransportControls](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediatransportcontrols.aspx) simplifie la personnalisation des contrôles de transport d’un [MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx). Dans Windows 8.1, vous pouviez activer les contrôles de transport intégrés de MediaElement ou créer vos propres contrôles de transport qui appelaient des méthodes MediaElement. Vous pouvez désormais utiliser la fonctionnalité MediaTransportControls tout en personnalisant l’aspect convenant le mieux à votre application.
Notifications de modification de propriété | Dans les applications Windows universelles, vous pouvez suivre les changements de propriétés de DependencyObjects, et ce même pour des propriétés sans événements de changement correspondants. La notification fonctionne comme un événement, mais elle est en fait affichée sous forme de rappel. Le rappel prend un argument sender comme un gestionnaire d’événements, mais il ne prend pas d’argument d’événement. À la place, seul l’identificateur de propriété est transmis pour indiquer la propriété. Avec ces informations, votre application peut définir un gestionnaire unique pour plusieurs notifications de propriété. Pour plus d’informations, voir [RegisterPropertyChangedCallback](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dependencyobject.registerpropertychangedcallback.aspx) et [UnregisterPropertyChangedCallback](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback.aspx).
Cartes | La classe [MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx) a été mise à jour afin de fournir des images aériennes en 3D et des affichages au niveau de la rue. Ces nouvelles fonctionnalités et la fonctionnalité de cartographie précédente sont désormais disponibles dans les applications Windows universelles. Ajoutez un mappage à votre application avec les API suivantes: [Windows.UI.Xaml.Controls.Maps](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.aspx) et [Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx). Pour commencer à utiliser ces API dans une application Windows universelle dès aujourd’hui, demandez une clé auprès du [Centre de développement de Bing Cartes](https://www.bingmapsportal.com/). Pour en savoir plus, voir [Comment authentifier une application Cartes](https://msdn.microsoft.com/library/windows/apps/xaml/dn741528.aspx). Autre nouveauté dans Windows10, les utilisateurs de PC et de téléphones peuvent télécharger des cartes hors connexion à partir de l’application Paramètres. Les cartes hors connexion, quand elles sont disponibles, sont utilisées par la classe [MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx) pour afficher les cartes en l’absence de connexion Internet.
Mappage du bouton de sélection de l’entrée | La classe [Windows.UI.Xaml.Input.KeyEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.keyroutedeventargs.aspx) inclut une nouvelle propriété [OriginalKey](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.keyroutedeventargs.originalkey.aspx). Associée à une mise à jour correspondante apportée à l’élément [Windows.System.VirtualKey](https://msdn.microsoft.com/library/windows/apps/windows.system.virtualkey.aspx), cette propriété vous permet d’obtenir le bouton de sélection d’entrée d’origine, non mappé, associé à l’événement d’entrée sur le clavier.
Entrée manuscrite | Il est désormais plus simple d’utiliser la fonctionnalité d’entrée manuscrite, très fiable, dans les applications WindowsRuntime enC++,C# ou Visual Basic, grâce au contrôle [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx) et aux classes [InkPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkpresenter.aspx) sous-jacentes. Le contrôle [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx) définit une zone de superposition pour le dessin et le rendu des traits d’encre. Les fonctionnalités de ce contrôle (entrée, traitement et rendu) proviennent des classes [InkPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkpresenter.aspx), [InkStroke](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkstroke.aspx), [InkRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkrecognizer.aspx) et [InkSynchronizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inksynchronizer.aspx). **Important:** Ces classes ne sont pas prises en charge dans les applications Windows en JavaScript.


## <a name="updated-xaml-features"></a>FonctionnalitésXAML mises à jour

Fonctionnalité | Description
 :---- | :----
Mises à jour de CommandBar et AppBar | Les contrôles [CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx) et [AppBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbar) ont été mis à jour pour inclure une API, un comportement et une expérience utilisateur cohérents pour les applications UWP sur différentes familles d’appareils. <br /><br />Le contrôle CommandBar pour applications Windows universelles a été amélioré pour proposer un sur-ensemble de fonctionnalités AppBar et une meilleure flexibilité d’utilisation dans votre application. Utilisez CommandBar pour toutes les nouvelles applications Windows universelles sous Windows10. Dans un contrôle CommandBar sous Windows8.1, vous ne pouviez utiliser que les contrôles qui implémentaient [ICommandBarElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.icommandbarelement.aspx), [AppBarButton](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbarbutton.aspx) par exemple. Dans les applications Windows universelles, vous pouvez désormais insérer du contenu personnalisé dans le contrôle CommandBar, en plus d’AppBarButtons. <br /><br />Le contrôle AppBar a été mis à jour pour vous permettre de migrer plus facilement vos applications Windows8.1 utilisant AppBar vers la plateforme Windows universelle. AppBar a été conçu pour une utilisation avec des applications en plein écran et pour être appelé par des mouvements latéraux. Il est mis à jour pour des problèmes tels que les applications fenêtrées et l’absence de mouvements latéraux dans Windows10. <br /><br />Le contrôle masqué [AppBar.ClosedDisplayMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbar.closeddisplaymode.aspx), disponible auparavant sur WindowsPhone uniquement, est désormais pris en charge sur toutes les familles d’appareils, vous permettant ainsi de choisir entre différents niveaux de conseils relatifs aux commandes. AppBar propose un conseil minimal par défaut pour plus de cohérence lors de la mise à niveau de vos applications Windows8.1 en applications Windows universelles, dans lesquelles vous ne pouvez plus compter sur la prise en charge par la plateforme des mouvements latéraux.
Mises à jour de GridView | Avant Windows10, l’orientation de la disposition GridView par défaut était horizontale sur Windows et verticale sur WindowsPhone. Dans les applications UWP, GridView utilise une disposition verticale par défaut pour toutes les familles d’appareils, garantissant ainsi une expérience par défaut identique.
Propriété AreStickyGroupHeadersEnabled | Lorsque vous affichez des données groupées dans une disposition [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) ou [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx), les en-têtes de groupe restent désormais affichés lorsque vous faites défiler la liste. Ceci est utile dans les ensembles de données importants dans lesquels l’en-tête permet à l’utilisateur de connaître le contexte des données qu’il consulte. Toutefois, lorsque chaque groupe ne contient qu’un faible nombre d’éléments, vous souhaiterez peut-être désactiver le défilement des en-têtes. Pour contrôler ce comportement, vous pouvez définir la propriété AreStickyGroupHeadersEnabled sur [ItemsStackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemsstackpanel.aspx) ou [ItemsWrapGrid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemswrapgrid.aspx).
Méthode GroupHeaderContainerFromItemContainer | Lorsque vous affichez des données groupées dans une disposition [ItemsControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemscontrol.aspx), vous pouvez appeler la méthode [GroupHeaderContainerFromItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer.aspx) afin d’obtenir une référence sur l’en-tête parent du groupe. Par exemple, si un utilisateur supprime le dernier élément d’un groupe, vous pouvez obtenir une référence sur l’en-tête du groupe et supprimer l’élément et l’en-tête du groupe simultanément.
Événement ChoosingGroupHeaderContainer | Le nouvel événement [ChoosingGroupHeaderContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer.aspx) de [ListViewBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.aspx) vous permet de définir l’état des en-têtes de groupe dans une disposition ListView ou GridView. Par exemple, vous pouvez gérer cet événement pour définir la propriété [AutomationProperties.Nameproperty](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.automationproperties.nameproperty.aspx) sur l’en-tête du groupe afin de représenter le groupe dans des technologies d’assistance.
Événement ChoosingItemContainer | Le nouvel événement [ChoosingItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosingitemcontainer.aspx) de ListViewBase vous permet de mieux contrôler la virtualisation de l’interface utilisateur dans une disposition [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) ou [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx). Utilisez cet événement avec l’événement [ContainerContentChanging](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.containercontentchanging.aspx) pour gérer votre file de conteneurs recyclés à partir desquels dessiner si nécessaire. Par exemple, si la source de données a été réinitialisée en raison d’un filtrage, vous pouvez rapidement mettre en correspondance un ensemble de visuels (ItemContainers) et leurs données pour de meilleures performances.
Virtualisation du défilement de liste |Les contrôles [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) et [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) du langageXAML présentent un nouvel événement [ListViewBase.ChooseingItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosingitemcontainer.aspx), qui améliore leurs performances du contrôle en cas de modification de la collecte de données. Au lieu d’effectuer une réinitialisation complète de la liste (ce qui relance l’animation d’ouverture), le système gère désormais les éléments compris actuellement dans l’affichage, ainsi que l’état du focus et de la sélection. Les éléments nouveaux et supprimés dans la fenêtre d’affichage s’animent en douceur. Lorsqu’une modification est apportée à la collecte de données dans laquelle des conteneurs ne sont pas détruits, une application peut rapidement faire correspondre des «anciens» éléments à leur conteneur précédent et ignorer le traitement plus approfondi des méthodes de remplacement de cycle de vie de conteneur. Seuls les «nouveaux» éléments sont traités et associés aux conteneurs recyclés ou nouveaux.
Méthode SelectRange et propriété SelectedRanges | Dans les applications Windows universelles, les contrôles [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) et [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) vous permettent désormais de sélectionner des éléments en termes de plages d’index d’élément plutôt que de références d’objet d’élément. Cette méthode est plus efficace pour décrire la sélection d’élément, car les objets ne doivent pas nécessairement être créés pour chaque élément sélectionné. Pour plus d’informations, voir [ListViewBase.SelectedRanges](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.selectedranges.aspx), [ListViewBase.SelectRange](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.selectrange.aspx) et [ListViewBase.DeselectRange](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.deselectrange.aspx).
Nouvelles API ListViewItemPresenter | [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) et [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) utilisent des présentateurs d’élément pour proposer les visuels par défaut pour la sélection et le focus. Dans les applications UWP, [ListViewItemPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.listviewitempresenter.aspx) et [GridViewItemPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.gridviewitempresenter.aspx) incluent de nouvelles propriétés qui vous permet de mieux personnaliser les visuels des éléments de liste. Les nouvelles propriétés sont CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground et SelectedPressedBackground.
Mises à jour de SemanticZoom | Le comportement du contrôle [SemanticZoom](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.semanticzoom.aspx) est désormais identique pour les applications UWP sur toutes les familles d’appareils. L’action par défaut de basculement entre l’affichage détaillé et l’affichage plus général consiste à appuyer sur un en-tête de groupe dans l’affichage détaillé. Ce comportement est identique à celui sur Windows Phone8.1, à l’exception que sur Windows8.1 le zoom est obtenu via un pincement. Pour changer d’affichage via pincer pour zoomer, définissez [ScrollViewer.ZoomMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.zoommode.aspx) sur «Enabled» dans le ScrollViewer interne de SemanticZoom. <br /><br />Dans les applications Windows universelles, l’affichage plus général remplace l’affichage détaillé et prend la même taille que l’affichage qu’il remplace. Ce comportement est identique à celui sur Windows8.1, à la différence que sur Windows Phone8.1 l’affichage plus général était en plein écran et qu’il s’affichait au premier plan de tout autre contenu.
Mises à jour de DatePicker et TimePicker | Les contrôles [DatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepicker.aspx) et [TimePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.timepicker.aspx) proposent désormais une implémentation identique des applications Windows universelles sur toutes les familles d’appareils. Leur aspect est également totalement nouveau dans Windows10. La partie contextuelle du contrôle utilise désormais les contrôles [DatePickerFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepickerflyout.aspx) et [TimePickerFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.timepickerflyout.aspx) sur tous les appareils. Ce comportement est identique à celui sur Windows Phone8.1, hormis le fait que Windows8.1 utilisait des contrôles [ComboBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.combobox.aspx). L’utilisation de contrôles volants vous permet de créer facilement des sélecteurs de date et d’heure personnalisés.
Nouvelles API ScrollViewer | [ScrollViewer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.aspx) inclut de nouveaux événements [DirectManipulationStarted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted.aspx) et [DirectManipulationCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted.aspx) pour informer votre application lorsque vous touchez des boutons de début et d’arrêt de panoramique. Vous pouvez gérer ces événements pour coordonner votre interface utilisateur avec ces actions de l’utilisateur.
Mises à jour de MenuFlyout | Dans les applications Windows universelles, de nouvelles API vous permettent de créer plus facilement de meilleurs menus contextuels. La nouvelle méthode [MenuFlyout.ShowAt](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.menuflyout.showat.aspx) vous permet de spécifier où vous souhaitez que le menu volant apparaisse par rapport à un autre élément. (Et votre MenuFlyout peut même dépasser les limites de la fenêtre de votre application.) Utilisez la nouvelle classe [MenuFlyoutSubItem](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.menuflyoutsubitem.aspx) pour créer des menus en cascade.
Nouvelles propriétés de bordure pour ContentPresenter, Grid et StackPanel | Les contrôles de conteneur courants incluent de nouvelles propriétés de bordure vous permettant de tracer une bordure sans ajouter un autre élément de bordure à votre XAML. [ContentPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentpresenter.aspx), [Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx), et [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx) incluent les nouvelles propriétés suivantes: BorderBrush, BorderThickness, CornerRadius et Padding.
Nouvelles API de texte sur ContentPresenter | [ContentPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentpresenter.aspx) inclut de nouvelles API vous permettant de mieux contrôler l’affichage du texte: LineHeight, LineStackingStrategy, MaxLines et TextWrapping.
Visuels de focus système | Les visuels de focus des contrôles XAML sont désormais créés par le système au lieu d’être déclarés en tant qu’éléments XAML dans le modèle de contrôle. Les visuels de focus ne sont généralement pas nécessaires sur les appareils mobiles. Le système peut ainsi les créer et les gérer si nécessaires, améliorant ainsi les performances applicatives. Si vous souhaitez disposer d’un meilleur contrôle des visuels de focus, vous pouvez remplacer le comportement du système en fournissant un modèle de contrôle personnalisé qui définit les visuels de focus. Pour plus d’informations, voir [UseSystemFocusVisuals](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.usesystemfocusvisuals.aspx) et [IsTemplateFocusTarget](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.istemplatefocustargetproperty.aspx).
PasswordBox.PasswordRevealMode | Dans les applications Windows universelles, la propriété [PasswordRevealMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.passwordbox.passwordrevealmode.aspx) remplace la propriété IsPasswordRevealButtonEnabled pour proposer un comportement homogène sur les différentes familles d’appareils. **Attention:** Avant Windows10, le bouton d’affichage du mot de passe ne s’affichait pas par défaut, ce qui est le cas dans les applicationsWindows universelles. Si la sécurité de votre application requiert que le mot de passe soit toujours masqué, veillez à définir PasswordRevealMode sur Hidden.
Control.IsTextScaleFactorEnabled | La propriété [IsTextScaleFactorEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.istextscalefactorenabledproperty.aspx), qui était disponible sous WindowsPhone8.1, l’est désormais pour les applications Windows universelles sur toutes les familles d’appareils.
AutoSuggestBox | Le contrôle [AutoSuggestBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.aspx) de WindowsPhone8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils, et vous devez l’utiliser à la place de [SearchBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.searchbox.aspx). AutoSuggestBox propose des suggestions à mesure que l’utilisateur saisit, et fonctionne parfaitement avec différents types de saisie comme le toucher, le clavier et les éditeurs de méthode d’entrée. Il inclut également de nouveaux éléments qui fonctionnent mieux en tant que zone de recherche: la propriété [QueryIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.queryicon.aspx) et l’événement [QuerySubmitted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.querysubmitted.aspx).
ContentDialog | Le contrôle [ContentDialog](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentdialog.aspx) de WindowsPhone8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils. ContentDialog vous permet d’afficher une boîte de dialogue modale personnalisée parfaitement adaptée à toute la gamme d’appareils.
Pivot | Le contrôle [Pivot](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivot.aspx) de WindowsPhone8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils. Vous pouvez maintenant utiliser le même contrôle Pivot dans votre application pour appareils mobiles et de bureau. Pivot offre un comportement adaptatif basé sur la taille de l’écran et le type d’entrée. Vous pouvez personnaliser un contrôle Pivot pour qu’il fonctionne comme un onglet, avec différents affichages d’informations dans chaque élément.

## <a name="text"></a>Texte

Fonctionnalité | Description
 :---- | :----
API texte Windows Core | Le nouvel espace de noms [Windows.UI.Text.Core](https://msdn.microsoft.com/library/windows/apps/windows.ui.text.core.aspx) présente un système client/serveur, qui centralise le traitement de la saisie au clavier sur un seul serveur. Vous pouvez l’utiliser pour manipuler la mémoire tampon de modification de votre contrôle d’entrée de texte personnalisé. Le serveur d’entrée de texte garantit la synchronisation permanente des contenus de votre contrôle d’entrée de texte et de sa mémoire tampon de modification, via un canal de communication asynchrone entre l’application et le serveur.
Icônes vectorielles | L’élément [Glyphs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.aspx) inclut les nouvelles propriétés [IsColorFontEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.iscolorfontenabled.aspx) et [ColorFontPalleteIndex](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.colorfontpaletteindex.aspx) pour prendre en charge les polices couleur; vous pouvez désormais utiliser un fichier de police pour le rendu des icônes basées sur une police. Lorsque vous utilisez ColorFontPalleteIndex pour changer de palette de couleurs, une icône peut être rendue dans différents jeux de couleurs; par exemple, pour afficher une version activée et désactivée de l’icône.
Événements de fenêtre d’éditeur de méthode d’entrée | Les utilisateurs saisissent parfois du texte via un éditeur de méthode d’entrée qui s’affiche dans une fenêtre sous une zone de saisie de texte (généralement pour les langues d’Asie orientale). Vous pouvez utiliser l’événement CandidateWindowBoundsChanged et la propriété DesiredCandidateWindowAlignment de [TextBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.aspx) et [RichEditBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.richeditbox.aspx) pour que l’interface utilisateur de votre application s’adapte mieux à la fenêtre IME.
Événements de composition de texte | [TextBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.aspx) et [RichEditBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.richeditbox.aspx) incluent de nouveaux événements pour informer votre application lorsque du texte est composé à l’aide d’un éditeur de méthode d’entrée: TextCompositionStarted, TextCompositionEnded et TextCompositionChanged. Vous pouvez gérer ces événements afin de coordonner le code de votre application avec le processus de composition IME. Par exemple, vous pouvez implémenter une fonctionnalité de saisie automatique insérée pour les langues de l’Asie orientale.
Meilleure gestion du texte bidirectionnel | Les contrôles de texte XAML incluent une nouvelle API afin d’améliorer la gestion du texte bidirectionnel, d’où un meilleur alignement du texte et une meilleure orientation des paragraphes dans diverses langues d’entrée. La valeur par défaut de la propriété TextReadingOrder a été remplacée par DetectFromContent, activant ainsi par défaut la détection de l’ordre de lecture. La propriété TextReadingOrder a également été ajoutée à PasswordBox, RichEditBox et à TextBox. Vous pouvez définir la propriété TextAlignment des contrôles de texte sur la nouvelle valeur DetectFromContent pour que l’alignement du contenu puisse être détecté automatiquement.
Rendu du texte | Dans Windows10, le texte des applications XAML est maintenant rendu, dans la plupart des cas, quasiment deuxfois plus rapidement que sur Windows8.1. Dans la plupart des cas, vos applications tireront profit de cette amélioration sans les modifier. Ces améliorations, qui accélèrent le rendu, réduisent également de 5% en moyenne la consommation de mémoire des applicationsXAML.

## <a name="application-model"></a>Modèle d’application

Fonctionnalité | Description
 :---- | :----
Cortana | Complétez la fonctionnalité de base de Cortana avec des commandes vocales qui lancent et exécutent une action unique dans une application externe. Cortana peut servir de lien entre votre application et l’utilisateur en intégrant la fonctionnalité de base de votre application et en fournissant un point d’entrée central à l’utilisateur pour qu’il puisse accomplir la plupart des tâches sans ouvrir directement votre application. Dans de nombreux cas, cela permet à l’utilisateur de gagner un temps considérable. Découvrez comment [intégrer votre application au canevas Cortana](https://msdn.microsoft.com/library/windows/apps/xaml/dn974230.aspx). Si vous cherchez des idées, consultez les recommandations en matière de conception et d’expérience utilisateur propres à Cortana dans les [Notions de base pour la conception d’applications Windows universelles](https://developer.microsoft.com/windows/design/layout).
Explorateur de fichiers | La nouvelle méthode [Windows.System.Launcher.LaunchFolderAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchfolderasync.aspx) vous permet de lancer l’Explorateur de fichiers. Elle affiche également le contenu du dossier que vous spécifiez.
Stockage partagé | La nouvelle classe [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.sharedstorageaccessmanager.aspx) ainsi que ses méthodes vous permettent de partager un fichier avec une autre application en transmettant un jeton de partage lorsque vous lancez l’autre application à l’aide de l’activation de l’URI. L’application cible échange le jeton pour obtenir le fichier partagé par l’application source.
Paramètres | Affichez les pages de paramètres intégrés en utilisant le protocole ms-settings avec la méthode [LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx). Par exemple, le code suivant affiche la page de paramètres Wi-Fi: **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Pour obtenir la liste des pages de paramètres que vous pouvez afficher, voir [Comment afficher les pages de paramètres intégrés à l’aide du protocole ms-settings](https://msdn.microsoft.com/library/windows/apps/jj207014.aspx).
Communication entre les applications | Dans Windows10, les nouvelles API de [communication entre les applications](https://msdn.microsoft.com/library/windows/apps/xaml/dn997827.aspx) permettent aux applications Windows (ainsi qu’aux applications Web Windows) de se lancer les unes les autres et d’échanger des données et des fichiers. Grâce à ces nouvelles API, les tâches complexes qui, auparavant, auraient obligé l’utilisateur à lancer plusieurs applications, peuvent désormais être gérées de manière transparente. Ainsi, votre application peut démarrer une application de réseau social pour choisir un contact, ou une application de validation pour effectuer un processus de paiement.
Services d’application | Les services d’application permettent à une application de fournir des services à d’autres applications dans Windows10. Il s’exécute sous la forme d’une tâche en arrière-plan. Les applications de premier plan peuvent appeler un service d’application dans une autre application afin d’exécuter des tâches en arrière-plan. Pour en savoir plus sur l’API de services d’application, voir [Windows.ApplicationModel.AppService](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.appservice.aspx).
Manifeste du package de l’application | Dans les mises à jour apportées à la référence de [schéma de manifeste de package](https://msdn.microsoft.com/library/windows/apps/br211474.aspx) de Windows10, certains éléments ont été ajoutés, supprimés et modifiés. Pour consulter des informations de référence sur l’ensemble des éléments, attributs et types du schéma, voir [Hiérarchie d’éléments](https://msdn.microsoft.com/library/windows/apps/dn934819.aspx).

## <a name="devices"></a>Devices

Fonctionnalité | Description
 :---- | :----
Hub Microsoft Surface | Le MicrosoftSurfaceHub est un puissant appareil de collaboration en équipe et une plateforme à grand écran pour les applications Windows universelles s’exécutant en mode natif à partir de SurfaceHub ou de votre appareil connecté. Développez vos propres applications en fonction de votre activité, et valorisez le grand écran, les fonctionnalités de saisie tactile et manuscrite tout en profitant du nombre important de matériel intégré, comme les appareils photo et les capteurs.<br /><br />Consultez les recommandations en matière de conception et d’expérience utilisateur propres au hub Surface dans les [Notions de base pour la conception d’applications Windows universelles](https://developer.microsoft.com/windows/design/layout). Cette documentation décrit les techniques de design réactif pour les applications Universal Windows app. <br /><br />Pour plus d’informations sur la prise en charge des applications partagées par la communauté, voir [SharedModeSettings](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.sharedmodesettings.aspx). Pour plus d’informations sur l’entrée manuscrite et la prise en charge de l’entrée manuscrite multipoint dans le nouveau contrôle [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx), voir [Windows.UI.Input.Inking](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.aspx) et [Windows.UI.Input.Inking.Core](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.core.aspx). Pour plus d’informations sur la gestion de l’entrée du capteur, voir [Intégration des appareils, des imprimantes et des capteurs](https://msdn.microsoft.com/library/windows/apps/xaml/br229563.aspx).
Emplacement | Windows10 introduit une nouvelle méthode pour demander à l’utilisateur l’autorisation d’accéder à son emplacement, [RequestAccessAsync](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.requestaccessasync.aspx). L’utilisateur définit la confidentialité de ses données d’emplacement à l’aide des **paramètres de confidentialité de l’emplacement** de l’application **Paramètres**. Votre application peut accéder à l’emplacement de l’utilisateur dans les cas suivants uniquement: le paramètre **Emplacement de cet appareil** est activé *(non applicable dans Windows10 pour smartphones)*, le paramètre des services de localisation **Emplacement** est activé, et, sous **Choisir les applications qui peuvent utiliser votre emplacement**, votre application est activée. <br /><br />Il est important d’invoquer **RequestAccessAsync** avant d’accéder à l’emplacement de l’utilisateur. À ce stade, votre application doit être au premier plan et l’élément **RequestAccessAsync** doit être appelé à partir du thread d’interface utilisateur. Jusqu’à ce que l’utilisateur l’y autorise, votre application ne peut pas accéder aux données d’emplacement.
AllJoyn | L’espace de noms Windows Runtime [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/windows.devices.alljoyn.aspx) introduit l’implémentation par Microsoft de l’infrastructure et des services de logiciel open source AllJoyn. Ces API permettent à votre application pour appareil Windows universelle de participer avec d’autres appareils à des scénarios Internet des objets, pilotés par AllJoyn. Pour plus d’informations sur lesAPI AllJoyn, téléchargez la documentation à l’adresse [The AllSeen Alliance](https://allseenalliance.org/). Utilisez l’outil [AllJoynCodeGen](https://msdn.microsoft.com/library/windows/apps/dn913809.aspx) inclus dans cette publication pour générer un composant Windows qui vous permet d’activer des scénariosAllJoyn dans l’application de votre appareil. <br /><br />**Remarque:** Windows10IoTStandard est désormais disponible pour une nouvelle classe de petits appareils. Ainsi, vous êtes en mesure de créer des appareils dédiés à l’Internet des objets à l’aide de Windows et de Visual Studio. Pour en savoir plus sur [WindowsIoT, accédez au Centre de développement Windows](https://developer.microsoft.com/windows/iot).
Impression des API sur mobile (XAML) | Il s’agit d’un ensemble unifié et simple d’API qui vous permet d’imprimer à partir de vos applications UWP basées sur XAML sur différentes familles d’appareils, notamment les appareils mobiles. Vous pouvez désormais ajouter l’impression à votre application mobile grâce à des API d’impression familières des espaces de noms Windows.Graphics.Printing et Windows.UI.Xaml.Printing.
Autonomie | Les API de la batterie dans l’espace de noms [Windows.Devices.Power](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.aspx) permettent à votre application d’en savoir plus sur les batteries qui sont connectées à l’appareil qui exécute votre application. Créez un objet [Batterie](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.aspx) pour représenter un contrôleur de batterie individuel ou un agrégat de l’ensemble des contrôleurs de batterie (s’ils sont créés respectivement par [FromIdAsync](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.fromidasync.aspx) ou [AggregateBattery](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.aggregatebattery.aspx)). Utilisez la méthode [GetReport](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.getreport.aspx) pour retourner un objet [BatteryReport](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.batteryreport.aspx) indiquant la charge, la capacité et l’état des batteries correspondantes.
PériphériquesMIDI | Le nouvel espace de noms [Windows.Devices.Midi](https://msdn.microsoft.com/library/windows/apps/windows.devices.midi.aspx) vous permet de créer les éléments suivants: applications, qui peuvent communiquer avec des appareilsMIDI externes; applications et appareils externes, qui communiquent directement avec le synthétiseur logiciel MicrosoftGSMIDI; et scénarios dans lesquels plusieurs clients accèdent simultanément à un seul portMIDI.
Prise en charge de capteurs personnalisés | L’espace de noms [Windows.Devices.Sensors.Custom](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.custom.aspx) permet aux développeurs de matériel de définir de nouveaux types de capteur personnalisé, comme les capteurs de CO2.
HCE (Host-based Card Emulation) | La fonction d’émulation de carte hôte (HCE) vous permet d’implémenter des services d’émulation de carte NFC hébergés par le système d’exploitation, tout en restant capable de communiquer avec le terminal de lecteur externe, via la technologie de radioNFC. Pour déclencher une tâche en arrière-plan afin d’émuler une carte à puce par le biais de la fonctionNFC, utilisez la classe [SmartCardTrigger](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.background.smartcardtrigger.aspx). La valeur EmulatorHostApplicationActivated de l’énumération [SmartCardTriggerType](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.smartcards.smartcardtriggertype.aspx) permet à votre application de savoir qu’un événementHCE est survenu.

## <a name="graphics"></a>Graphismes

Fonctionnalité | Description
 :---- | :----
DirectX | DirectX12 dans Windows10 introduit la nouvelle version de Microsoft Direct3D, l’API de graphiques3D au cœur de DirectX. Les [Graphismes Direct3D 12](https://msdn.microsoft.com/library/windows/desktop/dn903821(v=vs.85).aspx) prennent en charge l’efficacité et les performances d’une API de niveau inférieur, de type console. Direct3D12 est plus rapide et plus efficace que jamais. Il permet des scènes plus riches, un plus grand nombre d’objets et des effets plus complexes. Il tire également mieux parti du matériel graphique moderne.
SoftwareBitmapSource | Dans les applications Windows universelles, vous pouvez utiliser le type [SoftwareBitmapSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.softwarebitmapsource.aspx) comme source d’image XAML. Il vous permet de transmettre des images non codées à l’infrastructure XAML afin de les afficher directement à l’écran en ignorant le décodage d’image de l’infrastructure XAML. Vous obtenez ainsi un rendu plus rapide de l’image, comme le rendu de photos à faible décalage de l’appareil photo directement, la capture d’images de surfaces DirectX, voire la création de bout en bout d’images en mémoire et leur rendu direct dans XAML avec une faible latence et une faible surcharge de la mémoire.
Caméra perspective | Dans les applications Windows universelles, XAML inclut une nouvelle API Transform3D qui vous permet d’appliquer des transformations de perspective à une arborescence XAML (ou une scène), et qui transforme tous les éléments enfants XAML en fonction de cette transformation à l’échelle de la scène (ou de la caméra). Vous pouviez le faire auparavant avec MatrixTransform et des fonctions mathématiques complexes, mais Transform3D simplifie considérablement cet effet et permet également de l’animer. Pour plus d’informations, voir la propriété [UIElement.Transform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx), [Transform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.transform3d.aspx), [CompositeTransform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.compositetransform3d.aspx) et [PerspectiveTransform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.perspectivetransform3d.aspx).

## <a name="media"></a>Multimédia

Fonctionnalité | Description
 :---- | :----
DiffusionHTTP en continu | La nouvelle classe [AdaptiveMediaSource](https://msdn.microsoft.com/library/windows/apps/windows.media.streaming.adaptive.adaptivemediasource.aspx) vous permet d’ajouter à vos applications des fonctionnalités de flux vidéo adaptatif. L’objet est initialisé en le pointant vers un fichier manifeste de streaming. Les formats de manifeste pris en charge sont les suivants: HLS (HTTP Live Streaming) et DASH (Dynamic Adaptive Streaming over HTTP). Une fois que l’objet est lié à un élément multimédiaXAML, la lecture adaptative commence. Les propriétés du flux de données, telles que les vitesses de transmission disponibles, minimale et maximale, peuvent être interrogées et définies le cas échéant.
Prise en charge du processeurXVP (Transcode Video Processor) de Media Foundation pourMFT (Media Foundation Transforms) | Les applications Windows qui utilisentMFT peuvent désormais utiliser le **processeurXVP (Transcode Video Processor) de MediaFoundation** pour convertir, mettre à l’échelle et transformer des données vidéo brutes: le nouvel attribut [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://msdn.microsoft.com/library/windows/desktop/dn803919.aspx) active la sortie sur des textures allouées à l’appelant, même en mode Microsoft DirectX Video Acceleration (DXVA). Avec la nouvelle interface [IMFVideoProcessorControl2](https://msdn.microsoft.com/library/windows/desktop/dn800741.aspx), votre application peut activer les effets de matériel, demander les effets de matériel pris en charge et remplacer l’opération de rotation effectuée par le processeur vidéo.
Transcodage | La nouvelle API [MediaProcessingTrigger](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.background.mediaprocessingtrigger.aspx) permet à votre application d’effectuer le transcodage multimédia dans une tâche en arrière-plan, afin que vos opérations de transcodage puissent continuer même lorsque votre application au premier plan a été arrêtée.
Événements d’échecs multimédias MediaElement | Dans une application Windows universelle, [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx) lit le contenu comportant plusieurs flux, même en cas d’erreur de décodage de l’un des flux, tant que le contenu multimédia comporte au moins un flux de données valide. Par exemple, si le flux vidéo d’un contenu comportant un élément audio et un flux vidéo échoue, [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx) continue de lire le flux audio. [PartialMediaFailureDetected](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected.aspx) vous avertit que l’un des flux ne peut pas être décodé. Il vous permet également de savoir quel type de flux a échoué afin que vous puissiez refléter ces informations dans votre interface utilisateur. Si tous les flux au sein d’un flux multimédia échouent, l’événement [MediaFailed](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.mediafailed.aspx) est déclenché.
Prise en charge de la diffusion de vidéos en continu adaptative avec MediaElement | [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx) inclut la nouvelle méthode [SetPlaybackSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.setplaybacksource.aspx) pour prendre en charge la diffusion de vidéos en continu adaptative. Utilisez cette méthode pour définir votre source multimédia sur AdaptiveMediaSource.
Transtypage avec MediaElement et Image | Les contrôles [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx) et Image incluent la nouvelle méthode [GetAsCastingSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.getascastingsource.aspx). Vous pouvez utiliser cette méthode pour envoyer par programmation du contenu d’un élément multimédia ou image à une plus large gamme d’appareils distants tels que Miracast, Bluetooth et DLNA.Cette fonctionnalité est activée automatiquement lorsque vous définissez [AreTransportControlsEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled.aspx) sur vrai dans un MediaElement.
Contrôles de transport de média pour les applications de bureau | L’interface [ISystemMediaTransportControls](https://msdn.microsoft.com/library/windows/desktop/dn892299(v=vs.85).aspx) et l’API associée autorisent les applications de bureau à interagir avec les contrôles de transport de média intégrés. Cela inclut la réponse aux interactions utilisateur avec les boutons de contrôle de transport et la mise à jour de l’affichage des contrôles de transport pour visualiser les métadonnées concernant le contenu multimédia en cours de lecture.
Codage et décodage JPEG à accès aléatoire | Les nouvelles méthodes WIC [IWICJpegFrameEncode](https://msdn.microsoft.com/library/windows/desktop/dn903864(v=vs.85).aspx) et [IWICJpegFrameDecode](https://msdn.microsoft.com/library/windows/desktop/dn903834(v=vs.85).aspx) permettent le codage et le décodage des images JPEG. Vous pouvez également activer l’indexation des données d’image, qui fournit un accès aléatoire efficace à des images volumineuses au détriment d’une plus grande quantité de mémoire.
Superpositions pour compositions multimédias | Les nouvelles API [MediaOverlay](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.editing.mediaoverlay.aspx) et [MediaOverlayLayer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.editing.mediaoverlaylayer.aspx) simplifient l’ajout de plusieurs couches de contenu multimédia statique ou dynamique à une composition multimédia. L’opacité, la position et le minutage peuvent être ajustés pour chaque couche, et vous pouvez même implémenter votre propre compositeur personnalisé pour les couches d’entrée.
Nouvelle infrastructure d’effets | L’espace de noms [Windows.Media.Effects](https://msdn.microsoft.com/library/windows/apps/windows.media.effects.aspx) fournit une infrastructure simple et intuitive pour ajouter des effets aux flux audio et vidéo. L’infrastructure inclut des interfaces de base que vous pouvez implémenter pour créer des effets vidéos et audio personnalisés et pour insérer ces derniers dans le pipeline multimédia.

## <a name="networking"></a>Mise en réseau

Fonctionnalité | Description
 :---- | :----
Sockets | Mises à jour de socket: <br /><br />**Broker de socket:** Le service Broker de socket peut établir et fermer des connexions de socket au nom d’une application se trouvant dans tout état de son cycle de vie. De ce fait, les applications et les services qu’elles fournissent sont plus facilement détectables. Exemple: par le biais du service Broker de socket, un service Win32 peut toujours accepter les connexions de socket entrantes même s’il n’est pas en cours d’exécution. <br /><br />**Améliorations de débit:** Le débit de socket a été optimisé pour les applications qui utilisent l’espace de noms Windows.Networking.Sockets.
Tâches de post-traitement de transfert en arrière-plan | Les nouvelles API de l’espace de noms [Windows.Networking.BackgroundTransfer](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx) vous permettent d’inscrire des groupes de tâches de post-traitement. Votre application peut donc agir dès la réussite ou l’échec des transferts en arrière-plan, même si elle n’est pas au premier plan, au lieu d’attendre sa prochaine reprise par l’utilisateur.
Prise en charge Bluetooth pour les annonces | Avec l’espace de noms [Windows.Devices.Bluetooth.Advertisement](https://msdn.microsoft.com/library/windows/apps/windows.devices.bluetooth.advertisement.aspx), vos applications peuvent envoyer, recevoir et filtrer des annonces BluetoothLE.
Mise à jour de l’API Wi-Fi Direct | Le service Broker pour appareils est mis à jour pour activer le couplage avec des appareils sans quitter l’application. Des ajouts dans l’espace de noms [Windows.Devices.WiFiDirect](https://msdn.microsoft.com/library/windows/apps/windows.devices.wifidirect.aspx) permettent également aux autres appareils de détecter plus facilement un appareil, lequel peut détecter les notifications de connexion entrante.<br /><br />**Remarque:** Dans cette version, les améliorations de la fonctionnalité Wi-Fi Direct ne sont pas intégrées dans l’expérience utilisateur, et elles ne prennent en charge que le couplage rapide. En outre, cette version ne prend en charge qu’une seule connexion active.
Améliorations de la prise en chargeJSON | L’espace de noms [Windows.Data.Json](https://msdn.microsoft.com/library/windows/apps/windows.data.json.aspx) assure désormais une meilleure prise en charge des définitions standard existantes et de l’expérience développeur lors de la conversion des objetsJSON au cours des sessions de débogage.

## <a name="security"></a>Sécurité

Fonctionnalité | Description
 :---- | :----
ChiffrementECC | Les nouvellesAPI de l’espace de noms [Windows.Security.Cryptography](https://msdn.microsoft.com/library/windows/apps/windows.security.cryptography.aspx) assurent la prise en charge du chiffrement à courbe elliptique (ECC), une implémentation de chiffrement à clé publique basée sur des courbes elliptiques dans des domaines limités. Le chiffrementECC est d’un point de vue mathématique plus complexe que le chiffrementRSA. Il fournit des clés de taille inférieure, réduit la consommation de la mémoire et améliore les performances. Il offre aux services et clients Microsoft une alternative aux clésRSA et aux paramètres de courbe approuvés par leNIST.
Microsoft Passport | Microsoft Passport est une méthode d’authentification qui remplace les mots de passe par un geste et un chiffrement asymétrique. Les classes de l’espace de noms Credentials, comme [KeyCredentialManger](https://msdn.microsoft.com/library/windows/apps/windows.security.credentials.keycredentialmanager.aspx), facilitent la création d’applications au moyen de Microsoft Passport, sans qu’il soit nécessaire de recourir aux technologies de chiffrement ou de biométrie, très complexes.
Version professionnelle de Microsoft Passport | Cette méthode alternative de connexion à Windows utilise le compte MicrosoftAzureActiveDirectory, mais n’exploite aucun mot de passe, carte à puce ou carte à puce virtuelle. Vous pouvez activer ou désactiver ce paramètre de stratégie.
Courtier de jetons | Ce courtier est une nouvelle structure d’authentification qui facilite la connexion des applications aux fournisseurs d’identité en ligne, comme Facebook. Les fonctionnalités telles que la gestion du nom d’utilisateur et du mot de passe du compte, associées à une interface utilisateur rationalisée, fournissent une expérience d’authentification considérablement améliorée aux utilisateurs.

## <a name="system-services"></a>Services système

Fonctionnalité | Description
 :---- | :----
Alimentation | Votre application de bureau Windows peut maintenant être avertie lorsque l’économiseur de batterie est activé ou désactivé. En réponse au changement des conditions d’alimentation, votre application peut contribuer à prolonger l’autonomie de la batterie. <br /><br />[GUID_POWER_SAVING_STATUS](https://msdn.microsoft.com/library/windows/desktop/hh448380.aspx): Utilisez ce nouveauGUID avec la fonction [PowerSettingRegisterNotification](https://msdn.microsoft.com/library/windows/desktop/hh769082(v=vs.85).aspx) pour être averti de l’activation ou de la désactivation de l’économiseur de batterie. <br /><br />[SYSTEM_POWER_STATUS](https://msdn.microsoft.com/library/windows/desktop/aa373232.aspx): Cette structure a été mise à jour pour gérer l’économiseur de batterie. Le quatrièmemembre, *SystemStatusFlag* (anciennement Reserved1) indique maintenant si l’économiseur de batterie est activé ou non. Utilisez la fonction [GetSystemPowerStatus](https://msdn.microsoft.com/library/windows/desktop/aa372693(v=vs.85).aspx) pour récupérer un pointeur vers cette structure.
Version | Vous pouvez utiliser les [fonctions d’assistance de version](https://msdn.microsoft.com/library/windows/desktop/dn424972.aspx) pour déterminer la version du système d’exploitation. Pour Windows10, ces fonctions d’assistance incluent une nouvelle fonction, [IsWindows10OrGreater](https://msdn.microsoft.com/library/windows/desktop/dn905474(v=vs.85).aspx). Pour déterminer la version du système, vous devez utiliser les fonctions d’assistance plutôt que les fonctions déconseillées [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) et [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx). Pour plus d’informations sur la procédure à suivre afin de connaître la version du système, voir [Obtention de la version du système](https://msdn.microsoft.com/library/windows/desktop/ms724429.aspx). <br /><br />Si vous utilisez la fonction déconseillée [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) ou [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx) pour obtenir les informations de version d’une structure [OSVERSIONINFOEX](https://msdn.microsoft.com/library/windows/desktop/ms724833(v=vs.85).aspx) ou [OSVERSIONINFO](https://msdn.microsoft.com/library/windows/desktop/ms724834.aspx), sachez que le numéro de version contenu dans ces structures s’accroît et passe de6.3 pour Windows8.1 et Windows Server2012R2 à10.0 pour Windows10. Pour plus d’informations sur les numéros de version du système d’exploitation, voir [Version du système d’exploitation](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx). <br /><br />Vous devez également cibler spécifiquement Windows8.1 ou Windows10 dans votre application pour obtenir les informations de version correctes correspondant à ces versions avec la fonction [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) ou [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx). Pour en savoir plus sur le ciblage de votre application pour ces versions de Windows, voir [Ciblage de votre application pour Windows](https://msdn.microsoft.com/library/windows/desktop/dn481241.aspx).
Informations sur les utilisateurs | Les nouvelles API de l’espace de noms [Windows.System](https://msdn.microsoft.com/library/windows/apps/windows.system.aspx) facilitent l’accès aux informations sur un utilisateur (nom d’utilisateur et photo associée au compte, par exemple). Par ailleurs, elles permettent de répondre aux événements utilisateur (connexion et déconnexion, par exemple).
Profilage et gestion de mémoire | La prise en charge des API de profilage de mémoire dans [Windows.System](https://msdn.microsoft.com/library/windows/apps/windows.system.aspx) a été étendue à l’ensemble de plateformes. De plus, les fonctionnalités globales de cesAPI ont été améliorées, grâce à l’ajout de nouvelles classes et fonctions.

## <a name="storage"></a>Stockage

Fonctionnalité | Description
 :---- | :----
API de recherche de fichiers disponibles pour Windows Phone | En tant qu’éditeur d’application, vous pouvez inscrire votre application pour partager un dossier de stockage avec d’autres applications que vous publiez en ajoutant des extensions au manifeste de l’application. Appelez ensuite la méthode [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.getpublishercachefolder.aspx) pour obtenir l’emplacement de stockage partagé. Le modèle de sécurité renforcée des applications Windows Runtime empêche généralement les applications de se partager les données. Néanmoins, il peut s’avérer utile pour des applications du même éditeur de partager des fichiers et des paramètres en fonction des utilisateurs.

## <a name="tools"></a>Outils

Fonctionnalité | Description
 :---- | :----
Arborescence visuelle en direct dans Visual Studio | Visual Studio inclut une nouvelle fonctionnalité d’arborescence visuelle en direct. Vous pouvez l’utiliser lors du débogage pour déterminer rapidement l’état de l’arborescence visuelle de votre application, et pour savoir comment les propriétés d’élément sont définies. Elle vous permet également de modifier des valeurs de propriété pendant l’exécution de votre application, vous permettant ainsi de la modifier et de l’essayer sans la relancer.
Journalisation du suivi | [TraceLogging](https://msdn.microsoft.com/library/windows/desktop/dn904636(v=vs.85).aspx) est une nouvelle API de suivi d’événements pour les applications en mode utilisateur et les pilotes en mode noyau ; elle repose sur le [suivi d’événements pour Windows](https://msdn.microsoft.com/library/windows/desktop/bb968803(v=vs.85).aspx) (ETW). CetteAPI fournit un moyen simplifié d’orchestrer le code et d’inclure des données structurées avec des événements sans nécessiter de fichiermanifesteXML d’instrumentation distinct. Les API WinRT, .NET et C/C++ TraceLogging satisfont différents publics de développeurs.

## <a name="user-experience"></a>Expérience utilisateur

Fonctionnalité | Description
 :---- | :----
Reconnaissance vocale | La reconnaissance vocale continue dans les scénarios de dictée longue est désormais prise en charge par la plateforme Windows universelle. Voir comment activer la dictée continue dans la documentation sur l’interaction vocale.
Fonctionnalités de glisser-déplacer entre différentes plateformes d’application | Le nouvel espace de noms [Windows.ApplicationModel.DataTransfer.DragDrop](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.dragdrop.aspx) apporte la fonctionnalité de glisser-déplacer aux applications Windows universelles. Auparavant, les scénarios de glisser-déplacer courants pour les programmes de bureau, par exemple le glissement d’un document à partir d’un dossier vers un message électronique Outlook afin de le joindre, n’étaient pas possibles avec les applications Windows universelles. À l’aide de ces nouvelles API, votre application permet aux utilisateurs de déplacer facilement des données entre différentes applications Windows universelles et le Bureau. <br /><br />Ces nouvelles API ont été ajoutées à XAML pour prendre en charge la fonctionnalité glisser-déplacer entre les applications: [ListViewBase.DragItemsCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.dragitemscompleted.aspx); <br />UIElement: [CanDrag](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.candrag.aspx), [DragStarting](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.dragstarting.aspx), [StartDragAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.startdragasync.aspx), [DropCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.dropcompleted.aspx);  <br />[DragOperationDeferral](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragoperationdeferral.aspx), [DragUI](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragui.aspx), [DragUIOverride](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.draguioverride.aspx); <br />DragEventArgs: [AcceptedOperation](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.acceptedoperation.aspx), [DataView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.dataview.aspx), [DragUIOverride](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.draguioverride.aspx), [GetDeferral](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.getdeferral.aspx), [Modifiers](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.modifiers.aspx); <br />[DragItemsCompletedEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.dragitemscompletedeventargs.aspx), [DropCompletedEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dropcompletedeventargs.aspx), [DragStartingEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragstartingeventargs.aspx)
Barres de titre de fenêtre personnalisées | Pour les applications UWP destinées à la famille d’appareils de bureau, vous pouvez désormais utiliser la classe [ApplicationViewTitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationviewtitlebar.aspx) avec la propriété [ApplicationView.TitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationview.titlebar.aspx) et la méthode [Window.SetTitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationview.titlebar.aspx) pour remplacer le contenu de la barre de titre Windows par défaut par votre propre contenu XAML personnalisé. Votre XAML est considéré comme du «superflu système», et Windows gérera donc les événements d’entrée au lieu de votre application. Cela signifie que l’utilisateur peut toujours faire glisser et redimensionner la fenêtre, même s’il clique sur votre contenu de barre de titre personnalisé.

## <a name="web"></a>Web

Fonctionnalité | Description
 :---- | :----
MicrosoftEdge | MicrosoftEdge est le nouveau navigateur par défaut conçu pour Windows10. Pour plus d’informations et une vue d’ensemble des normes et fonctionnalités de développement incluses dans MicrosoftEdge, notamment les dernières fonctionnalités JavaScript, voir le [Guide du développeur MicrosoftEdge](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide/).
Navigation WebView | Le contrôle [WebView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.aspx) utilise le même moteur de rendu que le nouveau navigateur Microsoft Edge. Il offre le mode le plus précis et conforme aux normes de rendu HTML.
WebView hors thread | Vous pouvez spécifier un [WebView.ExecutionMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.executionmode.aspx) pour autoriser le traitement et l’affichage de contenu web sur un thread en arrière-plan distinct. Dans certains scénarios bien précis, ceci peut améliorer les performances.
Événement WebView.UnsupportedUriSchemeIdentified | Le nouvel événement [WebView.UnsupportedUriSchemeIdentified](https://msdn.microsoft.com//library/windows/apps/windows.ui.xaml.controls.webview.unsupportedurischemeidentified.aspx) vous permet de choisir comment votre application doit traiter un schéma d’URI non pris en charge. Vous pouvez gérer cet événement de sorte que votre application gère les schémas d’URI non pris en charge de manière personnalisée. Pour le contrôle WebView HTML, voir l’événement [MSWebViewUnsupportedUriSchemeIdentified](https://msdn.microsoft.com/library/windows/apps/dn803906.aspx).
Événement WebView.NewWindowRequested | Le nouvel événement [WebView.NewWindowRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.newwindowrequested.aspx) vous permet de répondre lorsqu’un script de WebView demande l’ouverture d’une nouvelle fenêtre de navigateur. Pour le contrôle WebView HTML, voir l’événement [MSWebViewNewWindowRequested](https://msdn.microsoft.com/library/windows/apps/dn803905.aspx).
Événement WebView.PermissionRequested | Le nouvel événement [WebView.PermissionRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.permissionrequested.aspx) permet au contenu WebView de tirer profit des nouvelles API HTML5 qui exigent une autorisation spéciale de l’utilisateur comme la géolocalisation. Pour le contrôle WebView HTML, voir l’événement [MSWebViewPermissionRequested](https://msdn.microsoft.com/library/windows/apps/dn806030.aspx).
Événement WebView.UnviewableContentIdentified | Le nouvel événement [WebView.UnviewableContentIdentified](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.unviewablecontentidentified.aspx) vous permet de répondre lorsque WebView accède à du contenu non web comme un fichierPDF ou un document Office. Pour le contrôle WebView HTML, voir l’événement [MSWebViewUnviewableContentIdentified](https://msdn.microsoft.com/library/windows/apps/dn609716.aspx).
Méthode WebView.AddWebAllowedObject | Vous pouvez appeler la nouvelle méthode [WebView.AddWebAllowedObject](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.addweballowedobject.aspx) pour injecter un objet WinRT dans un WebView XAML, puis appeler ses fonctions à partir d’un JavaScript de confiance hébergé sur ce WebView. Par exemple, le contenu Web peut afficher des notifications système en demandant à son application parent d’appeler l’API WinRT [ToastNotificationManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.notifications.toastnotificationmanager.aspx). Pour le contrôle WebViewHTML, voir la méthode [addWebAllowedObject](https://msdn.microsoft.com/library/windows/apps/dn926632.aspx).
Méthode WebView.ClearTemporaryWebDataAsync | Lorsqu’un utilisateur interagit avec le contenu web d’un WebView XAML, le contrôle WebView met les données en cache en fonction de la session de cet utilisateur. Vous pouvez appeler la nouvelle méthode [ClearTemporaryWebDataAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.cleartemporarywebdataasync.aspx) pour effacer ce cache. Par exemple, vous pouvez effacer le cache lorsqu’un utilisateur se déconnecte de l’application pour qu’aucun autre utilisateur n’ait accès aux données de la session précédente.
