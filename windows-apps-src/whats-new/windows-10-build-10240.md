---
Description: Windows 10, build 10240 et les mises à jour des outils de développeurs continuent à fournir les fonctionnalités, expériences et outils pris en charge par la plateforme Windows universelle.
title: Nouveautés de Windows 10, build 10240 - Juillet 2015
keywords: nouveautés, nouveauté, mise à jour, mises à jour, fonctionnalités, nouveau, Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: 28eb1dfecf9f6648bd43606c541daf7b57960771
ms.sourcegitcommit: 6f32604876ed480e8238c86101366a8d106c7d4e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/21/2019
ms.locfileid: "67320443"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Nouveautés de Windows 10 pour les développeurs, build 10240

Windows 10, build 10240 et le SDK mis à jour offrent les outils, fonctionnalités et expériences pour créer de remarquables applications sur la plateforme Windows universelle. Après avoir [installé les outils et le Kit de développement logiciel](https://go.microsoft.com/fwlink/?LinkId=821431) sur Windows 10, vous êtes prêt à [créer une nouvelle application Windows universelle](../get-started/create-uwp-apps.md) ou à découvrir comment utiliser votre [code d’application existant sur Windows](../porting/index.md).

Voici un aperçu, fonction par fonction, des nouveautés qui vous attendent dans Windows 10, build 10240 (également appelé Windows 10, version 1507).

## <a name="adaptive-layouts"></a>Dispositions adaptatives

Fonctionnalité | Description
 :---- | ----:
Plusieurs vues pour le contenu personnalisé | XAML fournit une nouvelle prise en charge pour la définition de vues personnalisées (fichiers .xaml) partageant le même fichier de code. Ainsi, vous pouvez plus facilement créer et gérer différentes vues personnalisées pour une gamme d’appareils ou un scénario spécifiques. Si votre application inclut divers contenus, disposition ou modèles de navigation d’interface utilisateur qui sont complètement différents d’autres scénarios, créez plusieurs affichages. Par exemple, vous pouvez utiliser un contrôle [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot) avec une navigation optimisée pour l’utilisation d’une seule main dans votre application mobile et un contrôle [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView) avec un menu de navigation optimisé pour la souris dans votre application de bureau.
StateTriggers | Grâce à la nouvelle fonctionnalité [VisualState.StateTriggers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.statetriggers), vous pouvez définir des propriétés de manière conditionnelle en fonction de la hauteur/largeur de la fenêtre ou d’un déclencheur personnalisé. Auparavant, vous deviez gérer les événements de fenêtre [SizeChanged](https://docs.microsoft.com/uwp/api/windows.ui.xaml.window.sizechanged) dans le code et appeler [VisualStateManager.GotoState](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager.gotostate).
Setters | Grâce à la nouvelle syntaxe [VisualState.Setters](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.setters), vous pouvez utiliser un marquage simplifié pour définir des changements de propriété dans [VisualStateManager](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager). Auparavant, vous deviez utiliser une table de montage et créer des animations pour appliquer des changements de propriétés tels que le changement d’orientation d’un [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) de Horizontal à Vertical. Dans les applications Windows universelles, vous pouvez utiliser cette syntaxe Setter plus simple : <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>Fonctionnalités XAML

Fonctionnalité | Description
 :---- | :----
Liaisons de données compilées (x: Bind) | Dans les applications Windows universelles, vous pouvez utiliser le nouveau mécanisme de liaison basé sur un compilateur activé par la propriété x:Bind. Les liaisons basées sur compilateur étant fortement typées et traitées lors de la compilation, la procédure est accélérée et présente des erreurs de compilation en cas de défaut correspondance des types de liaison. Les liaisons étant traduites en code d’application compilé, vous pouvez désormais les déboguer en analysant le code dans Visual Studio, afin de diagnostiquer des problèmes spécifiques de liaison. Par ailleurs, vous pouvez utiliser la propriété x/Bind pour lier une méthode, comme ceci : <textblock text="{x:Bind Customer.Address.ToString()}" />Pour les scénarios de liaison typiques, utilisez x:Bind en lieu et place de Binding afin d’améliorer les performances et la maintenabilité.
Rendu incrémentiel déclaratif de listes (x:Phase) | Dans les applications Windows universelles, le nouvel attribut x:Phase vous permet d’effectuer un rendu incrémentiel, ou progressif, des listes à l’aide de XAML au lieu du code. Lors d’un mouvement panoramique effectué sur de longues listes comportant des éléments complexes, votre application peut avoir des difficultés à afficher les éléments suffisamment rapidement. Le cas échéant, l’expérience de vos utilisateurs est affectée négativement. Grâce au rendu progressif, vous êtes en mesure de spécifier la priorité de rendu des composants d’un élément de liste, de manière à afficher uniquement les portions les plus importantes de l’élément de liste dans les scénarios de panoramique rapide. Dès lors, votre utilisateur jouit d’une expérience de panoramique plus agréable. <br /><br /> Dans Windows 8.1, vous pouviez gérer l’événement [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) et écrire du code pour afficher progressivement des éléments de liste. Dans les applications UWP, vous pouvez obtenir un rendu progressif déclaratif grâce à l’attribut x:Phase. Utilisé conjointement avec les liaisons compilées x:Bind, l’attribut x:Phase vous permet de spécifier simplement une priorité de rendu pour chaque élément lié dans un modèle de données. Dans le cas d’un panoramique, le rendu des éléments est fractionné en fonction de la phase, qui permet un rendu incrémentiel des éléments.
Chargement différé d’éléments de l’interface utilisateur (x:deferLoadstrategy) | Dans les applications Windows universelles, la nouvelle directive x:deferLoadstrategy permet de spécifier des éléments de votre interface utilisateur à charger en différé, ce qui améliore les performances de démarrage et réduit l’utilisation de la mémoire de votre application. Par exemple, si l’interface utilisateur de votre application présente un élément de validation de données qui s’affiche uniquement lors de la saisie de données incorrectes, vous pouvez reporter au moment opportun le chargement de cet élément. Ensuite, les objets d’éléments ne sont pas créés au chargement de la page, mais uniquement en cas d’erreur de données et lorsqu’ils sont requis pour l’ajout à l’arborescence visuelle de la page.
SplitView | Le nouveau contrôle [SplitView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.splitview) vous permet d’afficher et de masquer facilement le contenu temporaire. Il est généralement utilisé dans les scénarios de navigation de niveau supérieur comme le « hamburger menu », dans lequel le contenu de navigation est masqué puis affiché si nécessaire en résultat d’une action de l’utilisateur.
RelativePanel | [RelativePanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.relativepanel) est un nouveau panneau de disposition qui vous permet de positionner et d’aligner des objets enfants les uns par rapport aux autres ou par rapport au panneau parent. Par exemple, vous pouvez définir une configuration suivant laquelle certains éléments textuels doivent toujours être positionnés à gauche du panneau et un élément Button toujours aligné sous le texte. Utilisez RelativePanel lors de la création d’interfaces utilisateur sans modèle linéaire précis dans lesquelles vous devriez utiliser [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) ou [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid).
CalendarView | Le contrôle [CalendarView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendarview) simplifie l’affichage et la sélection de dates et de plages de dates à l’aide d’un affichage mensuel personnalisable. CalendarView prend en charge des fonctionnalités telles que les dates minimum, maximum et blackout afin de limiter les dates pouvant être sélectionnées. Vous pouvez également définir des barres de densités personnalisées pouvant être utilisées pour afficher « l’exhaustivité » générale de la panification d’un jour donné.
CalendarDatePicker | [CalendarDatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendardatepicker) est un contrôle déroulant optimisé pour la sélection d’une seule date dans un CalendarView, dans lequel les informations contextuelles comme le jour de la semaine ou l’exhaustivité du calendrier sont importantes. Il est similaire au contrôle [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker), sauf que DatePicker est optimisé pour la sélection d’une date connue comme une date de naissance.
MediaTransportControls | La nouvelle classe [MediaTransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediatransportcontrols) simplifie la personnalisation des contrôles de transport d’un [MediaElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement). Dans Windows 8.1, vous pouviez activer les contrôles de transport intégrés de MediaElement ou créer vos propres contrôles de transport qui appelaient des méthodes MediaElement. Vous pouvez désormais utiliser la fonctionnalité MediaTransportControls tout en personnalisant l’aspect convenant le mieux à votre application.
Notifications de modifications de propriétés | Dans les applications Windows universelles, vous pouvez suivre les changements de propriétés de DependencyObjects, et ce même pour des propriétés sans événements de changement correspondants. La notification fonctionne comme un événement, mais elle est en réalité exposée comme un rappel. Le rappel traite l’argument sender comme un gestionnaire d’événements, sans traiter d’argument d’événement. À la place, seul l’identificateur de propriété est transmis. Avec ces informations, votre application peut définir un gestionnaire unique pour plusieurs notifications de propriétés. Pour plus d’informations, voir [RegisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) et [UnregisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback).
Cartes | La classe [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) a été mise à jour afin de fournir des images aériennes en 3D et des affichages au niveau de la rue. Ces nouvelles fonctionnalités et la fonctionnalité de cartographie précédente sont désormais disponibles dans les applications Windows universelles. Ajouter du mappage à votre application à l’aide des API suivantes : [Windows.UI.Xaml.Controls.Maps](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps) et [Windows.Services.Maps](https://docs.microsoft.com/uwp/api/windows.services.maps). Pour commencer à utiliser ces API dans une application Windows universelle dès aujourd’hui, demandez une clé auprès du [Centre de développement de Bing Cartes](https://www.bingmapsportal.com/). Pour en savoir plus, voir [Comment authentifier une application Cartes](https://docs.microsoft.com/previous-versions/windows/apps/dn741528(v=win.10)). Autre nouveauté dans Windows 10, les utilisateurs de PC et de téléphones peuvent télécharger des cartes hors connexion à partir de l’application Paramètres. Les cartes hors connexion, quand elles sont disponibles, sont utilisées par la classe [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) pour afficher les cartes en l’absence de connexion Internet.
Mappage de bouton d'entrée | La classe [Windows.UI.Xaml.Input.KeyEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs) inclut une nouvelle propriété [OriginalKey](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey). Associée à une mise à jour correspondante apportée à l’élément [Windows.System.VirtualKey](https://docs.microsoft.com/uwp/api/windows.system.virtualkey), cette propriété vous permet d’obtenir le bouton de sélection d’entrée d’origine, non mappé, associé à l’événement d’entrée sur le clavier.
Entrée manuscrite | Il est désormais plus simple d’utiliser la fonctionnalité d’entrée manuscrite, très fiable, dans les applications Windows Runtime en C++, C# ou Visual Basic, grâce au contrôle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) et aux classes [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter) sous-jacentes. Le contrôle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) définit une zone de superposition pour le dessin et le rendu des traits d’encre. Les fonctionnalités de ce contrôle (entrée, traitement et rendu) proviennent des classes [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter), [InkStroke](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkstroke), [InkRecognizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkrecognizer) et [InkSynchronizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inksynchronizer). **Important :** Ces classes ne sont pas prises en charge dans les applications Windows en JavaScript.


## <a name="updated-xaml-features"></a>Mises à jour des fonctionnalités XAML

Fonctionnalité | Description
 :---- | :----
Mises à jour CommandBar et AppBar | Les contrôles [CommandBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar) et [AppBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar) ont été mis à jour pour inclure une API, un comportement et une expérience utilisateur cohérents pour les applications UWP sur différentes familles d’appareils. <br /><br />Le contrôle CommandBar pour applications Windows universelles a été amélioré pour proposer un sur-ensemble de fonctionnalités AppBar et une meilleure flexibilité d’utilisation dans votre application. Utilisez CommandBar pour toutes les nouvelles applications Windows universelles sous Windows 10. Dans un contrôle CommandBar sous Windows 8.1, vous ne pouviez utiliser que les contrôles qui implémentaient [ICommandBarElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.icommandbarelement), [AppBarButton](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbarbutton) par exemple. Dans les applications Windows universelles, vous pouvez désormais insérer du contenu personnalisé dans le contrôle CommandBar, en plus d’AppBarButtons. <br /><br />Le contrôle AppBar a été mis à jour pour vous permettre de migrer plus facilement vos applications Windows 8.1 utilisant AppBar vers la plateforme Windows universelle. AppBar a été conçu pour une utilisation avec des applications en plein écran et pour être appelé par des mouvements latéraux. Les mises à jour du contrôle sont relatives aux problèmes associés aux applications fenêtrées et au manque de mouvements latéraux dans Windows 10. <br /><br />Le contrôle masqué [AppBar.ClosedDisplayMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode), disponible auparavant sur Windows Phone uniquement, est désormais pris en charge sur toutes les familles d’appareils, vous permettant ainsi de choisir entre différents niveaux de conseils relatifs aux commandes. AppBar propose un conseil minimal par défaut pour plus de cohérence lors de la mise à niveau de vos applications Windows 8.1 en applications Windows universelles, dans lesquelles vous ne pouvez plus compter sur la prise en charge par la plateforme des mouvements latéraux.
Mises à jour GridView | Avant Windows 10, l’orientation de la disposition GridView par défaut était horizontale sur Windows et verticale sur Windows Phone. Dans les applications UWP, GridView utilise une disposition verticale par défaut pour toutes les familles d’appareils, garantissant ainsi une expérience par défaut identique.
Propriété AreStickyGroupHeadersEnabled | Lorsque vous affichez des données groupées dans une disposition [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) ou [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview), les en-têtes de groupe restent désormais affichés lorsque vous faites défiler la liste. Cela est important dans les grands ensembles de données, pour lesquels l’en-tête fournit du contexte relatif aux données affichées par l’utilisateur. Toutefois, dans les situations où les groupes comportent uniquement quelques éléments, vous souhaiterez peut-être voir les en-têtes sortir de l’écran avec les éléments. Pour contrôler ce comportement, vous pouvez définir la propriété AreStickyGroupHeadersEnabled sur [ItemsStackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemsstackpanel) ou [ItemsWrapGrid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemswrapgrid).
Méthode GroupHeaderContainerFromItemContainer | Lorsque vous affichez des données groupées dans une disposition [ItemsControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol), vous pouvez appeler la méthode [GroupHeaderContainerFromItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer) afin d’obtenir une référence sur l’en-tête parent du groupe. Par exemple, si un utilisateur supprime le dernier élément d’un groupe, vous pouvez obtenir une référence à l’en-tête de groupe et supprimer simultanément l’élément et l’en-tête de groupe.
Événement ChoosingGroupHeaderContainer | Le nouvel événement [ChoosingGroupHeaderContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) de [ListViewBase](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase) vous permet de définir l’état des en-têtes de groupe dans une disposition ListView ou GridView. Par exemple, vous pouvez gérer cet événement pour définir la propriété [AutomationProperties.Nameproperty](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) sur l’en-tête du groupe afin de représenter le groupe dans des technologies d’assistance.
Événement ChoosingItemContainer | Le nouvel événement [ChoosingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) de ListViewBase vous permet de mieux contrôler la virtualisation de l’interface utilisateur dans une disposition [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) ou [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview). Utilisez cet événement avec l’événement [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) pour gérer votre file de conteneurs recyclés à partir desquels dessiner si nécessaire. Par exemple, si la source de données a été réinitialisée en raison du filtrage, vous pouvez rapidement mettre en correspondance un ensemble créé d’éléments visuels (ItemContainers) avec leurs données pour atteindre des performances supérieures.
Virtualisation du défilement des listes |Les contrôles [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) et [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) du langage XAML présentent un nouvel événement [ListViewBase.ChooseingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer), qui améliore leurs performances du contrôle en cas de modification de la collecte de données. Au lieu de réinitialiser entièrement la liste et d’activer une nouvelle lecture de l’animation d’entrée, le système gère désormais les éléments actuellement affichés, avec le focus et l’état de sélection. Les nouveaux éléments et les éléments supprimés de la fenêtre d’affichage entrent et sortent sans heurt de l’animation. Lorsqu’une modification est apportée à la collecte de données dans laquelle des conteneurs ne sont pas détruits, une application peut rapidement faire correspondre des « anciens » éléments à leur conteneur précédent et ignorer le traitement plus approfondi des méthodes de remplacement de cycle de vie de conteneur. Seuls les « nouveaux » éléments sont traités et associés aux conteneurs recyclés ou nouveaux.
Méthode SelectRange et propriété SelectedRanges | Dans les applications Windows universelles, les contrôles [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) et [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) vous permettent désormais de sélectionner des éléments en termes de plages d’index d’élément plutôt que de références d’objet d’élément. Il s’agit d’un moyen plus efficace de décrire des sélections d’éléments, dans la mesure où il n’est pas nécessaire de créer des objets d’élément pour chaque élément sélectionné. Pour plus d’informations, voir [ListViewBase.SelectedRanges](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges), [ListViewBase.SelectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange) et [ListViewBase.DeselectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange).
Nouvelles API ListViewItemPresenter | [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) et [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) utilisent des présentateurs d’élément pour proposer les visuels par défaut pour la sélection et le focus. Dans les applications UWP, [ListViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) et [GridViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) incluent de nouvelles propriétés qui vous permet de mieux personnaliser les visuels des éléments de liste. Les nouvelles propriétés sont CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground et SelectedPressedBackground.
Mises à jour SemanticZoom | Le comportement du contrôle [SemanticZoom](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.semanticzoom) est désormais identique pour les applications UWP sur toutes les familles d’appareils. L’action par défaut pour le basculement entre les zooms avant et arrière consiste à appuyer sur un en-tête de groupe dans le zoom avant. Il s’agit du comportement identifié sur Windows Phone 8.1, différent de celui respecté sur Windows 8.1. En effet, sur cette version, le basculement s’effectue à l’aide d’un pincement. Pour changer d’affichage via pincer pour zoomer, définissez [ScrollViewer.ZoomMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode) sur « Enabled » dans le ScrollViewer interne de SemanticZoom. <br /><br />Sur les applications Windows universelles, le zoom arrière remplace le zoom avant. Il présente la même taille que la vue remplacée. S’il s’agit du comportement rencontré sur Windows 8.1, il est différent de celui de Windows Phone 8.1, où le zoom arrière prenait toute la largeur de l’écran et apparaissait par-dessus l’ensemble des autres contenus.
Mises à jour DatePicker et TimePicker | Les contrôles [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker) et [TimePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepicker) proposent désormais une implémentation identique des applications Windows universelles sur toutes les familles d’appareils. Ils ont également une nouvelle apparence pour Windows 10. La partie contextuelle du contrôle utilise désormais les contrôles [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout) et [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout) sur tous les appareils. Ce comportement est identique à celui sur Windows Phone 8.1, hormis le fait que Windows 8.1 utilisait des contrôles [ComboBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.combobox). L’utilisation de contrôles volants vous permet de créer facilement des sélecteurs de date et d’heure personnalisés.
Nouvelles API ScrollViewer | [ScrollViewer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer) inclut de nouveaux événements [DirectManipulationStarted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) et [DirectManipulationCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted) pour informer votre application lorsque vous touchez des boutons de début et d’arrêt de panoramique. Vous pouvez gérer ces événements pour coordonner votre interface utilisateur avec ces actions utilisateur.
Mises à jour MenuFlyout | Dans les applications Windows universelles, vous trouverez de nouvelles API qui vous permettent de créer plus facilement des menus contextuels plus efficaces. La nouvelle méthode [MenuFlyout.ShowAt](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyout.showat) vous permet de spécifier où vous souhaitez que le menu volant apparaisse par rapport à un autre élément. (Et MenuFlyout peut même chevaucher les limites de la fenêtre de votre application.) Utilisez la nouvelle classe [MenuFlyoutSubItem](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem) pour créer des menus en cascade.
Nouvelles propriétés Border pour ContentPresenter, Grid et StackPanel | Les contrôles de conteneurs communs présentent de nouvelles propriétés de bordure. Grâce à ces dernières, vous pouvez tracer une bordure, sans ajouter aucun élément Border supplémentaire dans votre code XAML. [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter), [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid) et [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) présentent ces nouvelles propriétés : BorderBrush, BorderThickness, CornerRadius et Padding.
Nouvelles API textuelles sur ContentPresenter | [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter) comporte de nouvelles API qui vous offrent plus de contrôle sur l’affichage de texte : LineHeight, LineStackingStrategy, MaxLines et TextWrapping.
Visuels de focus système | Les visuels de focus des contrôles XAML sont désormais créés par le système, non pas déclarés en tant qu’éléments XAML dans le modèle de contrôle. Les visuels de focus ne sont généralement pas nécessaires sur les appareils mobiles. De fait, en laissant le système les créer et les gérer au besoin, vous améliorez les performances applicatives. Si vous avez besoin d’un contrôle supérieur sur les visuels de focus, vous pouvez remplacer le comportement du système en fournissant un modèle de contrôle personnalisé les définissant. Pour plus d’informations, voir [UseSystemFocusVisuals](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) et [IsTemplateFocusTarget](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty).
PasswordBox.PasswordRevealMode | Dans les applications Windows universelles, la propriété [PasswordRevealMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode) remplace la propriété IsPasswordRevealButtonEnabled pour proposer un comportement homogène sur les différentes familles d’appareils. **Attention :** Avant Windows 10, le bouton d’affichage du mot de passe ne s’affichait pas par défaut. C’est désormais le cas dans les applications Windows universelles. Si la sécurité de votre application nécessite que le mot de passe soit toujours masqué, définissez PasswordRevealMode sur Hidden.
Control.IsTextScaleFactorEnabled | La propriété [IsTextScaleFactorEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty), qui était disponible sous Windows Phone 8.1, l’est désormais pour les applications Windows universelles sur toutes les familles d’appareils.
AutoSuggestBox | Le contrôle [AutoSuggestBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox) de Windows Phone 8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils, et vous devez l’utiliser à la place de [SearchBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.searchbox). AutoSuggestBox propose des suggestions à mesure que l’utilisateur saisit, et fonctionne parfaitement avec différents types de saisie comme le toucher, le clavier et les éditeurs de méthode d’entrée. Il inclut également de nouveaux éléments qui fonctionnent mieux en tant que zone de recherche : la propriété [QueryIcon](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon) et l’événement [QuerySubmitted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted).
ContentDialog | Le contrôle [ContentDialog](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentdialog) de Windows Phone 8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils. ContentDialog vous permet d’afficher une boîte de dialogue modale personnalisée parfaitement adaptée à toute la gamme d’appareils.
Pivot | Le contrôle [Pivot](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot) de Windows Phone 8.1 est désormais disponible pour les applications Windows universelles sur toutes les familles d’appareils. Vous pouvez maintenant utiliser le même contrôle Pivot dans votre application pour appareils mobiles et de bureau. Pivot offre un comportement adaptatif basé sur la taille de l’écran et le type d’entrée. Vous pouvez personnaliser un contrôle Pivot pour qu’il fonctionne comme un onglet, avec différents affichages d’informations dans chaque élément.

## <a name="text"></a>Text

Fonctionnalité | Description
 :---- | :----
API Windows Core Text | Le nouvel espace de noms [Windows.UI.Text.Core](https://docs.microsoft.com/uwp/api/windows.ui.text.core) présente un système client/serveur, qui centralise le traitement de la saisie au clavier sur un seul serveur. Vous pouvez l’utiliser pour manipuler la mémoire-tampon de modification de votre contrôle de saisie de texte personnalisé. Le serveur de saisie de texte garantit la synchronisation du contenu de votre contrôle de saisie de texte et du contenu de sa propre mémoire-tampon de modification, via un canal de communication asynchrone entre l’application et le serveur.
Icônes de vecteur | L’élément [Glyphs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs) inclut les nouvelles propriétés [IsColorFontEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) et [ColorFontPalleteIndex](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) pour prendre en charge les polices couleur ; vous pouvez désormais utiliser un fichier de police pour le rendu des icônes basées sur une police. Lorsque vous utilisez ColorFontPalleteIndex pour changer de palette de couleurs, une icône peut être rendue dans différents jeux de couleurs ; par exemple, pour afficher une version activée et désactivée de l’icône.
Événements de la fenêtre Éditeur de méthode d'entrée | Parfois, les utilisateurs saisissent du texte dans un éditeur de méthode d’entrée qui s’affiche dans une fenêtre située juste en dessous d’une zone de saisie textuelle (généralement pour les langues d’Asie orientale). Vous pouvez utiliser l’événement CandidateWindowBoundsChanged et la propriété DesiredCandidateWindowAlignment de [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) et [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) pour que l’interface utilisateur de votre application s’adapte mieux à la fenêtre IME.
Événements de composition de texte | [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) et [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) incluent de nouveaux événements pour informer votre application lorsque du texte est composé à l’aide d’un éditeur de méthode d’entrée : TextCompositionStarted, TextCompositionEnded et TextCompositionChanged. Vous pouvez gérer ces événements afin de coordonner votre code d’application avec le processus de composition textuelle de l’Éditeur de méthode d'entrée. Par exemple, vous pouvez implémenter une fonctionnalité de saisie automatique inline pour les langues d’Asie orientale.
Gestion améliorée du texte bidirectionnel | Les contrôles textuels XAML présentent une nouvelle API améliorant la gestion du texte bidirectionnel. Vous profiter d’un meilleur alignement du texte et d’une directionnalité de paragraphe supérieure dans de nombreuses langues d’entrée. La valeur par défaut de la propriété TextReadingOrder a été remplacée par DetectFromContent, activant ainsi par défaut la détection de l’ordre de lecture. La propriété TextReadingOrder a également été ajoutée à PasswordBox, RichEditBox et à TextBox. Vous pouvez définir la propriété TextAlignment des contrôles de texte sur la nouvelle valeur DetectFromContent pour que l’alignement du contenu puisse être détecté automatiquement.
Rendu du texte | Dans Windows 10, le texte des applications XAML s’affiche, dans la plupart des situations, presque deux fois plus rapidement qu’avec Windows 8.1. Dans la plupart des cas, vos applications bénéficient de cette amélioration sans être par ailleurs affectée. Ces améliorations, qui accélèrent le rendu, réduisent également de 5 % en moyenne la consommation de mémoire des applications XAML.

## <a name="application-model"></a>Modèle d’application

Fonctionnalité | Description
 :---- | :----
Cortana | Complétez la fonctionnalité de base de Cortana avec des commandes vocales qui lancent et exécutent une action unique dans une application externe. Cortana peut servir de lien entre votre application et l’utilisateur en intégrant la fonctionnalité de base de votre application et en fournissant un point d’entrée central à l’utilisateur pour qu’il puisse accomplir la plupart des tâches sans ouvrir directement votre application. Dans de nombreux cas, cela permet à l’utilisateur de gagner beaucoup de temps et d’énergie. Découvrez comment [intégrer votre application au canevas Cortana](https://docs.microsoft.com/previous-versions/windows/apps/dn974230(v=win.10)). Si vous cherchez des idées, consultez les recommandations en matière de conception et d’expérience utilisateur propres à Cortana dans les [Notions de base pour la conception d’applications Windows universelles](https://docs.microsoft.com/windows/uwp/design/layout/index).
Explorateur de fichiers | La nouvelle méthode [Windows.System.Launcher.LaunchFolderAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchfolderasync) vous permet de lancer l’Explorateur de fichiers. Elle affiche également le contenu du dossier que vous spécifiez.
Stockage partagé | La nouvelle classe [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) ainsi que ses méthodes vous permettent de partager un fichier avec une autre application en transmettant un jeton de partage lorsque vous lancez l’autre application à l’aide de l’activation de l’URI. L’application cible utilise le jeton pour récupérer le fichier partagé par l’application source.
Paramètres | Affichez les pages de paramètres intégrés en utilisant le protocole ms-settings avec la méthode [LaunchUriAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchuriasync). Par exemple, le code suivant affiche la page de paramètres Wi-Fi : **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Pour obtenir la liste des pages de paramètres que vous pouvez afficher, voir [Comment afficher les pages de paramètres intégrés à l’aide du protocole ms-settings](https://docs.microsoft.com/previous-versions/windows/apps/jj207014(v=vs.105)).
Communication entre les applications | Dans Windows 10, les nouvelles API de [communication entre les applications](https://docs.microsoft.com/previous-versions/windows/apps/dn997827(v=win.10)) permettent aux applications Windows (ainsi qu’aux applications Web Windows) de se lancer les unes les autres et d’échanger des données et des fichiers. Grâce à ces nouvelles API, les tâches complexes qui, auparavant, auraient obligé l’utilisateur à lancer plusieurs applications, peuvent désormais être gérées de manière transparente. Ainsi, votre application peut démarrer une application de réseau social pour choisir un contact, ou une application de validation pour effectuer un processus de paiement.
Services d’application | Un service d’application permet à une application de fournir des services à d’autres applications dans Windows 10. Un service d’application prend la forme d’une tâche en arrière-plan. Les applications de premier plan peuvent appeler un service d’application dans une autre application afin d’exécuter les tâches en arrière-plan. Pour en savoir plus sur l’API de services d’application, voir [Windows.ApplicationModel.AppService](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppService).
Manifeste du package de l’application | Dans les mises à jour apportées à la référence de [schéma de manifeste de package](https://docs.microsoft.com/uwp/schemas/appxpackage/appx-package-manifest) de Windows 10, certains éléments ont été ajoutés, supprimés et modifiés. Pour consulter des informations de référence sur l’ensemble des éléments, attributs et types du schéma, voir [Hiérarchie d’éléments](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements).

## <a name="devices"></a>Appareils

Fonctionnalité | Description
 :---- | :----
Microsoft Surface Hub | Le Microsoft Surface Hub est un puissant appareil de collaboration en équipe et une plateforme à grand écran pour les applications Windows universelles s’exécutant en mode natif à partir de Surface Hub ou de votre appareil connecté. Développez vos propres applications en fonction de votre activité, et valorisez le grand écran, les fonctionnalités de saisie tactile et manuscrite tout en profitant du nombre important de matériel intégré, comme les appareils photo et les capteurs.<br /><br />Consultez les recommandations en matière de conception et d’expérience utilisateur propres au hub Surface dans les [Notions de base pour la conception d’applications Windows universelles](https://docs.microsoft.com/windows/uwp/design/layout/index). Ces documents fournissent des techniques de conception réactives pour les applications Windows universelles. <br /><br />Pour plus d’informations sur la prise en charge des applications partagées par la communauté, voir [SharedModeSettings](https://docs.microsoft.com/uwp/api/windows.system.profile.sharedmodesettings). Pour plus d’informations sur l’entrée manuscrite et la prise en charge de l’entrée manuscrite multipoint dans le nouveau contrôle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas), voir [Windows.UI.Input.Inking](https://docs.microsoft.com/uwp/api/windows.ui.input.inking) et [Windows.UI.Input.Inking.Core](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.core). Pour plus d’informations sur la gestion de l’entrée du capteur, voir [Intégration des appareils, des imprimantes et des capteurs](https://docs.microsoft.com/previous-versions/windows/apps/br229563(v=win.10)).
Emplacement | Windows 10 introduit une nouvelle méthode pour demander à l’utilisateur l’autorisation d’accéder à son emplacement, [RequestAccessAsync](https://docs.microsoft.com/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync). L’utilisateur définit la confidentialité de ses données d’emplacement avec les **paramètres de confidentialité d’emplacement** de l’application **Paramètres**. Votre application peut accéder à l’emplacement de l’utilisateur dans les cas suivants uniquement : Le paramètre **Emplacement de cet appareil** est activé *(non applicable dans Windows 10 pour smartphones)* , le paramètre des services de localisation **Emplacement** est activé, et, sous **Choisir les applications qui peuvent utiliser votre emplacement**, votre application est activée. <br /><br />Il est important d’invoquer **RequestAccessAsync** avant d’accéder à l’emplacement de l’utilisateur. À ce stade, votre application doit être au premier plan et l’élément **RequestAccessAsync** doit être appelé à partir du thread d’interface utilisateur. Jusqu’à ce que l’utilisateur l’y autorise, votre application ne peut pas accéder aux données d’emplacement.
AllJoyn | L’espace de noms Windows Runtime [Windows.Devices.AllJoyn](https://docs.microsoft.com/uwp/api/windows.devices.alljoyn) introduit l’implémentation par Microsoft de l’infrastructure et des services de logiciel open source AllJoyn. Ces API permettent à votre application pour appareil Windows universelle de participer avec d’autres appareils à des scénarios Internet des objets, pilotés par AllJoyn. Pour plus d’informations sur les API AllJoyn, téléchargez la documentation à l’adresse [The AllSeen Alliance](https://allseenalliance.org/). Utilisez l’outil [AllJoynCodeGen](https://docs.microsoft.com/previous-versions/windows/apps/dn913809(v=win.10)) inclus dans cette publication pour générer un composant Windows qui vous permet d’activer des scénarios AllJoyn dans l’application de votre appareil. <br /><br />**Remarque :** Windows 10 IoT Standard est désormais disponible pour une nouvelle classe de petits appareils. Ainsi, vous êtes en mesure de créer des appareils dédiés à l’Internet des objets à l’aide de Windows et de Visual Studio. Pour en savoir plus sur [Windows IoT, accédez au Centre de développement Windows](https://developer.microsoft.com/windows/iot).
API d’impression sur appareils mobiles (XAML) | Il existe un ensemble unique, unifié d’API que vous pouvez utiliser pour imprimer à partir de vos applications UWP basées sur XAML sur de nombreuses familles d’appareils, notamment sur les appareils mobiles. Vous pouvez désormais ajouter l’impression à votre application mobile grâce à des API d’impression familières des espaces de noms Windows.Graphics.Printing et Windows.UI.Xaml.Printing.
Batterie | Les API de la batterie dans l’espace de noms [Windows.Devices.Power](https://docs.microsoft.com/uwp/api/windows.devices.power) permettent à votre application d’en savoir plus sur les batteries qui sont connectées à l’appareil qui exécute votre application. Créez un objet [Batterie](https://docs.microsoft.com/uwp/api/windows.devices.power.battery) pour représenter un contrôleur de batterie individuel ou un agrégat de l’ensemble des contrôleurs de batterie (s’ils sont créés respectivement par [FromIdAsync](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.fromidasync) ou [AggregateBattery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.aggregatebattery)). Utilisez la méthode [GetReport](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.getreport) pour retourner un objet [BatteryReport](https://docs.microsoft.com/uwp/api/windows.devices.power.batteryreport) indiquant la charge, la capacité et l’état des batteries correspondantes.
Périphériques MIDI | Le nouvel espace de noms [Windows.Devices.Midi](https://docs.microsoft.com/uwp/api/windows.devices.midi) vous permet de créer les éléments suivants : applications, qui peuvent communiquer avec des appareils MIDI externes ; applications et appareils externes, qui communiquent directement avec le synthétiseur logiciel Microsoft GS MIDI ; et scénarios dans lesquels plusieurs clients accèdent simultanément à un seul port MIDI.
Prise en charge de capteurs personnalisés | L’espace de noms [Windows.Devices.Sensors.Custom](https://docs.microsoft.com/uwp/api/windows.devices.sensors.custom) permet aux développeurs de matériel de définir de nouveaux types de capteur personnalisé, comme les capteurs de CO2.
Émulation de carte basée sur l’hôte | L’émulation de carte basée sur l’hôte prend en charge l’implémentation de services d’émulation de carte NFC hébergés dans le système d’exploitation, ainsi que la communication avec le terminal de lecteur externe, via la radio NFC. Pour déclencher une tâche en arrière-plan afin d’émuler une carte à puce par le biais de la fonction NFC, utilisez la classe [SmartCardTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger). La valeur EmulatorHostApplicationActivated de l’énumération [SmartCardTriggerType](https://docs.microsoft.com/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) permet à votre application de savoir qu’un événement HCE est survenu.

## <a name="graphics"></a>Graphismes

Fonctionnalité | Description
 :---- | :----
DirectX | DirectX 12 dans Windows 10 introduit la nouvelle version de Microsoft Direct3D, l’API graphique 3D au cœur de DirectX. Les [Graphismes Direct3D 12](https://docs.microsoft.com/windows/desktop/direct3d12/direct3d-12-graphics) prennent en charge l’efficacité et les performances d’une API de niveau inférieur, de type console. Direct3D 12 est plus rapide et plus efficace que jamais. Cette solution permet des scènes plus riches, un plus grand nombre d’objets, des effets plus complexes et une meilleure utilisation du matériel graphique moderne.
SoftwareBitmapSource | Dans les applications Windows universelles, vous pouvez utiliser le nouveau type [SoftwareBitmapSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) en tant que source d’image XAML. Dès lors, vous pouvez intégrer des images non chiffrées dans la structure XAML et de les afficher immédiatement à l’écran, en contournant le décodage d’image de la structure. Vous obtenez un rendu d’image bien plus rapide, par exemple avec les photos à faible décalage directement depuis la caméra, via des décodeurs d’images personnalisés, avec la capture d’images à partir des surfaces DirectX ou en créant des images en mémoire avant de les afficher directement dans le code XAML avec une charge à faibles latence et encombrement de mémoire.
Caméra de perspective | Dans les applications Windows universelles, XAML inclut une nouvelle API Transform3D qui vous permet d’appliquer des transformations de perspective à une arborescence XAML (ou une scène), et qui transforme tous les éléments enfants XAML en fonction de cette transformation à l’échelle de la scène (ou de la caméra). Auparavant, cette opération s’effectuait à l’aide de MatrixTransform et de fonctions mathématiques complexes, mais Transform3D simplifie grandement cet effet, tout en prenant en charge son animation. Pour plus d’informations, voir la propriété [UIElement.Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.transform3d), [Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.transform3d), [CompositeTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d) et [PerspectiveTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d).

## <a name="media"></a>Support

Fonctionnalité | Description
 :---- | :----
Diffusion en continu en direct | La nouvelle classe [AdaptiveMediaSource](https://docs.microsoft.com/uwp/api/windows.media.streaming.adaptive.adaptivemediasource) vous permet d’ajouter à vos applications des fonctionnalités de flux vidéo adaptatif. Pour initialiser l’objet, pointez-le vers un fichier de manifeste de diffusion en continu. Parmi les formats de manifeste pris en charge, citons la diffusion en continu en direct HTTP et la diffusion en flux adaptatif dynamique sur HTTP. Une fois que l’objet est lié à un élément multimédia XAML, la lecture adaptative démarre. Les propriétés du flux, comme les débits disponibles, minimum et maximum peuvent être interrogés et définis au besoin.
Le processeur XVP (Transcode Video Processor) de Media Foundation prend en charge Media Foundation Transforms (MFT). | Les applications Windows qui utilisent Media Foundation Transforms peuvent désormais utiliser le **processeur XVP (Transcode Video Processor) de Media Foundation**  pour convertir, mettre à l’échelle et transformer des données vidéo brutes : Le nouvel attribut [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://docs.microsoft.com/windows/desktop/medfound/mf-xvp-caller-allocates-output) permet d’effectuer des sorties vers les textures allouées de l’appelant, même en mode DXVA (Microsoft DirectX Video Acceleration). Avec la nouvelle interface [IMFVideoProcessorControl2](https://docs.microsoft.com/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2), votre application peut activer les effets de matériel, demander les effets de matériel pris en charge et remplacer l’opération de rotation effectuée par le processeur vidéo.
Transcodage | La nouvelle API [MediaProcessingTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger) permet à votre application d’effectuer le transcodage multimédia dans une tâche en arrière-plan, afin que vos opérations de transcodage puissent continuer même lorsque votre application au premier plan a été arrêtée.
Événements de défaillance multimédia MediaElement | Dans une application Windows universelle, [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) lit le contenu comportant plusieurs flux, même en cas d’erreur de décodage de l’un des flux, tant que le contenu multimédia comporte au moins un flux de données valide. Par exemple, si le flux vidéo d’un contenu comportant un flux audio et un flux vidéo est mis en échec, l’élément [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) joue tout de même le flux audio. [PartialMediaFailureDetected](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) vous avertit que l’un des flux ne peut pas être décodé. Il vous indique également le type de flux mis en échec, de manière à ce que vous puissiez placer cette information dans votre interface utilisateur. Si tous les flux au sein d’un flux multimédia échouent, l’événement [MediaFailed](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed) est déclenché.
Prise en charge de la diffusion vidéo en continu adaptative avec MediaElement | [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) inclut la nouvelle méthode [SetPlaybackSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource) pour prendre en charge la diffusion de vidéos en continu adaptative. Utilisez cette méthode pour définir votre source multimédia sur AdaptiveMediaSource.
Diffusion multimédia avec MediaElement et Image | Les contrôles [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) et Image incluent la nouvelle méthode [GetAsCastingSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource). Vous pouvez utiliser cette méthode pour envoyer du contenu par programmation à partir de n'importe quel élément multimédia ou d’image à un éventail plus large de périphériques distants comme Miracast, Bluetooth et DLNA. Cette fonctionnalité est activée automatiquement lorsque vous définissez [AreTransportControlsEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) sur true dans un MediaElement.
Contrôles de transport multimédia pour les applications de bureau | L’interface [ISystemMediaTransportControls](https://docs.microsoft.com/previous-versions/windows/desktop/mediatransport/isystemmediatransportcontrols) et l’API associée autorisent les applications de bureau à interagir avec les contrôles de transport de média intégrés. Ainsi, les applications réagissent aux interactions des utilisateurs avec les boutons des contrôles de transport et mettent à jour l’affichage des contrôles de transport afin d’indiquer les métadonnées relatives au contenu multimédia actuellement lu.
Codage et décodage JPEG à accès aléatoire | Les nouvelles méthodes WIC [IWICJpegFrameEncode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframeencode) et [IWICJpegFrameDecode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframedecode) permettent le codage et le décodage des images JPEG. Vous pouvez également activer l’indexation des données d’image, qui fournit un accès aléatoire efficace aux images de grande taille, contre un plus grand encombrement mémoire.
Superpositions pour compositions multimédias | Les nouvelles API [MediaOverlay](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlay) et [MediaOverlayLayer](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlayLayer) simplifient l’ajout de plusieurs couches de contenu multimédia statique ou dynamique à une composition multimédia. L’opacité, la position et le minutage peuvent être ajustés pour chacune des couches, et vous pouvez même implémenter votre propre compositeur personnalisé pour les couches d’entrée.
Nouvelle infrastructure d’effets | L’espace de noms [Windows.Media.Effects](https://docs.microsoft.com/uwp/api/windows.media.effects) fournit une infrastructure simple et intuitive pour ajouter des effets aux flux audio et vidéo. L’infrastructure inclut des interfaces basiques que vous pouvez implémenter pour créer des effets audio et vidéo personnalisés, à insérer dans le pipeline multimédia.

## <a name="networking"></a>Mise en réseau

Fonctionnalité | Description
 :---- | :----
Sockets | Les mises à jour de socket incluent : <br /><br />**Broker de socket :** Le broker de socket peut établir et fermer les connexions de socket pour le compte d’une application, quel que soit l’état de cycle de vie de l’application. Dès lors, les applications et les services qu’elles fournissent sont davantage détectables. Par exemple, par le biais d’un broker de socket, un service Win32 peut toujours accepter les connexions entrantes de socket, même en dehors de l’état d’exécution. <br /><br />**Amélioration du débit :** Le débit de socket a été optimisé pour les applications qui utilisent l’espace de noms Windows.Networking.Sockets.
Tâches post-traitement du transfert en arrière-plan | Les nouvelles API de l’espace de noms [Windows.Networking.BackgroundTransfer](https://docs.microsoft.com/uwp/api/windows.networking.backgroundtransfer) vous permettent d’inscrire des groupes de tâches de post-traitement. Votre application peut donc agir dès la réussite ou l’échec des transferts en arrière-plan, même si elle n’est pas au premier plan, au lieu d’attendre sa prochaine reprise par l’utilisateur.
Prise en charge Bluetooth pour les publicités | Avec l’espace de noms [Windows.Devices.Bluetooth.Advertisement](https://docs.microsoft.com/uwp/api/windows.devices.bluetooth.advertisement), vos applications peuvent envoyer, recevoir et filtrer des annonces Bluetooth LE.
Mise à jour de l’API Wi-Fi Direct | Le broker d’appareil est mis à jour, pour activer le couplage avec les appareils, sans quitter l’application. Des ajouts dans l’espace de noms [Windows.Devices.WiFiDirect](https://docs.microsoft.com/uwp/api/windows.devices.wifidirect) permettent également aux autres appareils de détecter plus facilement un appareil, lequel peut détecter les notifications de connexion entrante.<br /><br />**Remarque :** Dans cette version, les améliorations de la fonctionnalité Wi-Fi Direct ne sont pas intégrées dans l’expérience utilisateur, et elles prennent en charge uniquement le couplage de réinitialisation rapide. Par ailleurs, cette version prend une seule connexion active en charge.
Améliorations de la prise en charge JSON | L’espace de noms [Windows.Data.Json](https://docs.microsoft.com/uwp/api/windows.data.json) assure désormais une meilleure prise en charge des définitions standard existantes et de l’expérience développeur lors de la conversion des objets JSON au cours des sessions de débogage.

## <a name="security"></a>Sécurité

Fonctionnalité | Description
 :---- | :----
Chiffrement ECC | Les nouvelles API de l’espace de noms [Windows.Security.Cryptography](https://docs.microsoft.com/uwp/api/windows.security.cryptography) prennent en charge le chiffrement à courbe elliptique (ECC), une implémentation de chiffrement à clé publique basée sur des courbes elliptiques sur des champs finis. ECC est plus complexe mathématiquement que RSA, fournit des clés de format plus réduit, réduit la consommation de mémoire et améliore les performances. Cette solution offre aux services et aux clients Microsoft une alternative aux clés RSA et aux paramètres de courbe approuvés par le NIST.
Microsoft Passport | Microsoft Passport est une autre méthode d'authentification, qui remplace les mots de passe par un chiffrement asymétrique associé à un mouvement. Les classes de l’espace de noms Credentials, comme [KeyCredentialManger](https://docs.microsoft.com/uwp/api/windows.security.credentials.keycredentialmanager), facilitent la création d’applications au moyen de Microsoft Passport, sans qu’il soit nécessaire de recourir aux technologies de chiffrement ou de biométrie, très complexes.
Microsoft Passport for Work | Microsoft Passport for Work est une autre méthode de connexion à Windows à l’aide de votre compte Azure Active Directory qui n’utilise pas de mot de passe, de carte à puce ou de cartes à puce virtuelles. Vous pouvez décider de désactiver ou d’activer ce paramètre de stratégie.
Broker à jetons | Le broker à jetons est une nouvelle infrastructure d’authentification qui simplifie pour les applications la procédure de connexion aux fournisseurs d’identité en ligne, comme Facebook. Les fonctionnalités telles que la gestion du nom d’utilisateur et du mot de passe du compte, associées à une interface utilisateur rationalisée, fournissent une expérience d’authentification considérablement améliorée aux utilisateurs.

## <a name="system-services"></a>Services système

Fonctionnalité | Description
 :---- | :----
Alimentation | Il est désormais possible de signaler à votre application de bureau Windows l’activation et la désactivation de l’économiseur de batterie. En réagissant à l’évolution des conditions d’alimentation, votre application peut étendre l’autonomie de la batterie. <br /><br />[GUID_POWER_SAVING_STATUS](https://docs.microsoft.com/windows/desktop/Power/power-setting-guids) : Utilisez ce nouveau GUID avec la fonction [PowerSettingRegisterNotification](https://docs.microsoft.com/windows/desktop/api/powersetting/nf-powersetting-powersettingregisternotification) pour être averti de l’activation ou de la désactivation de l’économiseur de batterie. <br /><br />[SYSTEM_POWER_STATUS](https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-_system_power_status) : Cette structure a été mise à jour pour gérer l’économiseur de batterie. Le quatrième membre, *SystemStatusFlag* (auparavant appelé Reserved1) indique si l’économiseur de batterie est activé. Utilisez la fonction [GetSystemPowerStatus](https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getsystempowerstatus) pour récupérer un pointeur vers cette structure.
Version | Vous pouvez utiliser les [fonctions d’assistance de version](https://docs.microsoft.com/windows/desktop/SysInfo/version-helper-apis) pour déterminer la version du système d’exploitation. Pour Windows 10, ces fonctions d’assistance incluent une nouvelle fonction, [IsWindows10OrGreater](https://docs.microsoft.com/windows/desktop/api/versionhelpers/nf-versionhelpers-iswindows10orgreater). Pour déterminer la version du système, vous devez utiliser les fonctions d’assistance plutôt que les fonctions déconseillées [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) et [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion). Pour plus d’informations sur la procédure à suivre pour connaître la version du système, voir [Obtention de la version du système](https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version). <br /><br />Si vous utilisez la fonction déconseillée [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) ou [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) pour obtenir les informations de version d’une structure [OSVERSIONINFOEX](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoexa) ou [OSVERSIONINFO](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoa), sachez que le numéro de version contenu dans ces structures s’accroît et passe de 6.3 pour Windows 8.1 et Windows Server 2012 R2 à 10.0 pour Windows 10. Pour plus d’informations sur les numéros de version du système d’exploitation, voir [Version du système d’exploitation](https://docs.microsoft.com/windows/desktop/SysInfo/operating-system-version). <br /><br />Vous devez également cibler spécifiquement Windows 8.1 ou Windows 10 dans votre application pour obtenir les informations de version correctes correspondant à ces versions avec la fonction [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) ou [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion). Pour en savoir plus sur le ciblage de votre application pour ces versions de Windows, voir [Ciblage de votre application pour Windows](https://docs.microsoft.com/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1).
Informations utilisateur | Les nouvelles API de l’espace de noms [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) facilitent l’accès aux informations sur un utilisateur (nom d’utilisateur et photo associée au compte, par exemple). Elles rendent également possibles la réponse à des événements utilisateur, comme les connexions et les déconnexions.
Gestion de la mémoire et profilage | La prise en charge des API de profilage de mémoire dans [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) a été étendue à l’ensemble de plateformes. De plus, les fonctionnalités globales de ces API ont été améliorées, grâce à l’ajout de nouvelles classes et fonctions.

## <a name="storage"></a>Stockage

Fonctionnalité | Description
 :---- | :----
API de recherche de fichiers disponibles pour Windows Phone | Comme un éditeur, vous pouvez configurer votre application pour partager un dossier de stockage avec d’autres applications, publié en ajoutant des extensions au manifeste d’application. Appelez ensuite la méthode [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://docs.microsoft.com/uwp/api/windows.storage.applicationdata.getpublishercachefolder) pour obtenir l’emplacement de stockage partagé. Le robuste modèle de sécurité des applications Windows Runtime empêche généralement les applications de partager des données entre elles. Néanmoins, il peut s’avérer utile pour des applications du même éditeur de partager des fichiers et des paramètres en fonction des utilisateurs.

## <a name="tools"></a>Outils

Fonctionnalité | Description
 :---- | :----
Arborescence visuelle en direct dans Visual Studio | Visual Studio dispose d’une nouvelle fonctionnalité d’arborescence visuelle en direct. Vous pouvez l'utiliser pendant le débogage pour comprendre rapidement l'état de l'arborescence visuelle de votre application et découvrir comment les propriétés de l’élément ont été définies. Elle vous permet également de modifier les valeurs des propriétés pendant l'exécution de votre application. Dès lors, vous pouvez effectuer des ajustements et des tests sans la relancer.
Journalisation du suivi | [TraceLogging](https://docs.microsoft.com/windows/desktop/tracelogging/trace-logging-portal) est une nouvelle API de suivi d’événements pour les applications en mode utilisateur et les pilotes en mode noyau ; elle repose sur le [suivi d’événements pour Windows](https://docs.microsoft.com/windows/desktop/ETW/event-tracing-portal) (ETW). Cette API fournit un moyen simplifié d’orchestrer le code et d’inclure des données structurées avec des événements sans nécessiter de fichier manifeste XML d’instrumentation distinct. Les API WinRT, .NET et C/C++ TraceLogging satisfont différents publics de développeurs.

## <a name="user-experience"></a>Expérience utilisateur

Fonctionnalité | Description
 :---- | :----
Reconnaissance vocale | La reconnaissance vocale continue pour les scénarios de dictée de longue durée est désormais prise en charge par la plateforme Windows universelle. Pour plus d’informations sur l’activation de la dictée continue, consultez les documents sur l’interaction vocale.
Fonctionnalités de glisser-déplacer entre différentes plateformes applicatives | Le nouvel espace de noms [Windows.ApplicationModel.DataTransfer.DragDrop](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.dragdrop) apporte la fonctionnalité de glisser-déplacer aux applications Windows universelles. Auparavant, les scénarios de glisser-déplacer courants pour les programmes de bureau, par exemple le glissement d’un document à partir d’un dossier vers un message électronique Outlook afin de le joindre, n’étaient pas possibles avec les applications Windows universelles. À l’aide de ces nouvelles API, votre application donne les moyens aux utilisateurs de déplacer facilement des données entre différentes applications Windows universelles et le bureau. <br /><br />Pour la prise en charge de la fonctionnalité glisser-déplacer entre les applications, ces nouvelles API ont été ajoutées au code XAML : [ListViewBase.DragItemsCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted) ; <br />UIElement : [CanDrag](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.candrag), [DragStarting](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting), [StartDragAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.startdragasync), [DropCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted) ;  <br />[DragOperationDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragoperationdeferral), [DragUI](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragui), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.draguioverride) ; <br />DragEventArgs : [AcceptedOperation](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation), [DataView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.dataview), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.draguioverride), [GetDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.getdeferral), [Modifiers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.modifiers) ; <br />[DragItemsCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs), [DropCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dropcompletedeventargs), [DragStartingEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragstartingeventargs)
Barres de titre des fenêtres personnalisées | Pour les applications UWP destinées à la famille d’appareils de bureau, vous pouvez désormais utiliser la classe [ApplicationViewTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) avec la propriété [ApplicationView.TitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) et la méthode [Window.SetTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) pour remplacer le contenu de la barre de titre Windows par défaut par votre propre contenu XAML personnalisé. Votre XAML est considéré comme du « superflu système », et Windows gérera donc les événements d’entrée au lieu de votre application. Dès lors, l’utilisateur peut toujours déplacer et redimensionner la fenêtre, même en cliquant sur le contenu de la barre de titre personnalisée.

## <a name="web"></a>Web

Fonctionnalité | Description
 :---- | :----
Microsoft Edge | Microsoft Edge est le nouveau navigateur par défaut conçu pour Windows 10. Pour plus d’informations et une vue d’ensemble des normes et fonctionnalités de développement incluses dans Microsoft Edge, notamment les dernières fonctionnalités JavaScript, voir le [Guide du développeur Microsoft Edge](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide).
Navigation WebView | Le contrôle [WebView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview) utilise le même moteur de rendu que le nouveau navigateur Microsoft Edge. Vous bénéficiez du mode de rendu HTML le plus précis et le plus conforme aux normes.
WebView hors thread | Vous pouvez spécifier un [WebView.ExecutionMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.executionmode) pour autoriser le traitement et l’affichage de contenu web sur un thread en arrière-plan distinct. Cette action peut améliorer les performances dans certains scénarios spécifiques.
Événement WebView.UnsupportedUriSchemeIdentified | Le nouvel événement [WebView.UnsupportedUriSchemeIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) vous permet de choisir comment votre application doit traiter un schéma d’URI non pris en charge. Vous pouvez gérer cet événement pour que votre application prenne en charge le traitement personnalisé des schémas d’URI non pris en charge. Pour le contrôle WebView HTML, voir l’événement [MSWebViewUnsupportedUriSchemeIdentified](https://docs.microsoft.com/previous-versions/windows/apps/dn803906(v=win.10)).
Événement WebView.NewWindowRequested | Le nouvel événement [WebView.NewWindowRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) vous permet de répondre lorsqu’un script de WebView demande l’ouverture d’une nouvelle fenêtre de navigateur. Pour le contrôle WebView HTML, voir l’événement [MSWebViewNewWindowRequested](https://docs.microsoft.com/microsoft-edge/webview).
Événement WebView.PermissionRequested | Le nouvel événement [WebView.PermissionRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) permet au contenu WebView de tirer profit des nouvelles API HTML5 qui exigent une autorisation spéciale de l’utilisateur comme la géolocalisation. Pour le contrôle WebView HTML, voir l’événement [MSWebViewPermissionRequested](https://docs.microsoft.com/previous-versions/windows/apps/dn806030(v=win.10)).
Événement WebView.UnviewableContentIdentified | Le nouvel événement [WebView.UnviewableContentIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) vous permet de répondre lorsque WebView accède à du contenu non web comme un fichier PDF ou un document Office. Pour le contrôle WebView HTML, voir l’événement [MSWebViewUnviewableContentIdentified](https://docs.microsoft.com/microsoft-edge/webview).
Méthode WebView.AddWebAllowedObject | Vous pouvez appeler la nouvelle méthode [WebView.AddWebAllowedObject](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) pour injecter un objet WinRT dans un WebView XAML, puis appeler ses fonctions à partir d’un JavaScript de confiance hébergé sur ce WebView. Par exemple, le contenu Web peut afficher des notifications système en demandant à son application parent d’appeler l’API WinRT [ToastNotificationManager](https://docs.microsoft.com/uwp/api/windows.ui.notifications.toastnotificationmanager). Pour le contrôle WebView HTML, voir la méthode [addWebAllowedObject](https://docs.microsoft.com/microsoft-edge/webview).
Méthode WebView.ClearTemporaryWebDataAsync | Lorsqu’un utilisateur interagit avec le contenu web d’un WebView XAML, le contrôle WebView met les données en cache en fonction de la session de cet utilisateur. Vous pouvez appeler la nouvelle méthode [ClearTemporaryWebDataAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) pour effacer ce cache. Par exemple, vous pouvez effacer le cache lorsqu’un utilisateur se déconnecte de l’application pour qu’aucun autre utilisateur n’ait accès aux données de la session précédente.
