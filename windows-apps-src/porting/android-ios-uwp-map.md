#Mappage de concepts d’applications Windows pour développeurs iOS et Android

Si vous êtes un développeur doté de compétences relatives aux systèmes d’exploitation Android ou iOS et au code et que vous souhaitez migrer vers Windows 10 et la plateforme Windows universelle (UWP), cette ressource vous permettra de mapper les fonctionnalités de la plateforme, et vos connaissances, entre les trois plateformes.

Voir également le contenu de portage dans [Migrer d’iOS vers UWP](ios-to-uwp-root.md).

## Interface utilisateur (UI)

|  **Concept général** | **Android** | **iOS** | **Plateforme Windows universelle Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Langage de conception.** Ensemble de conventions qui prévoient la manière dont les applications sur la plateforme doivent se présenter et se comporter. | Les recommandations en matière de **conception d’applications Android** fournissent un langage visuel à suivre par les concepteurs et développeurs Android. | Les **recommandations en matière d’interface utilisateur** fournissent des conseils aux concepteurs et développeurs iOS. | [
            **Conception et interface utilisateur**](https://dev.windows.com/design) vous montre comment créer une application parfaitement adaptée à tous les appareils Windows 10. Vous y trouverez des notions de base en matière de conception d’interface utilisateur (UI), des techniques de conception réactives et une liste complète de recommandations détaillées.<br/> |
|  **Langage de balisage d’interface utilisateur.** Langage de balisage effectuant le rendu et décrivant une interface utilisateur et ses composants. Chaque plateforme fournit un éditeur à des fins de modification visuelle et du balisage.<br/> | Modification des **dispositions XML** à l’aide d’**Android Studio** ou **Eclipse**. | Modification de **XIB** et **Storyboards** à l’aide d’**Interface Builder** dans Xcode. | Modification de **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)** à l’aide de **[Microsoft Visual Studio](https://www.visualstudio.com/)** et **[Blend pour Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)**.<br/><br/>[Plateforme XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[Créer une interface utilisateur avec XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[Définir des dispositions avec XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **Contrôles d’interface utilisateur intégrés.** Éléments d’interface utilisateur réutilisables fournis par la plateforme, tels que des boutons, des contrôles de liste et des contrôles de texte. | Classes **view** et **view group** prédéfinies désignées sous les termes widgets, dispositions, champs de texte, conteneurs, contrôles date/heure et contrôles d’expert. | **Vues** et **contrôles** de la bibliothèque d’objets Xcode et répertoriés dans le catalogue d’interface utilisateur UIKit. Les vues comprennent les vues d’images, les vues de sélecteur et les vues de défilement. Les contrôles comprennent les boutons, les sélecteurs de dates et les champs de texte. | La plateforme XAML propose un vaste ensemble de **contrôles intégrés**, tels que des boutons, des contrôles de liste, des panneaux, des contrôles de texte, des barres de commandes, des sélecteurs, du contenu multimédia et l’entrée manuscrite.<br/><br/>[Ajouter des contrôles et gérer les événements](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Gestion des événements de contrôle.** Définition de la logique qui s’exécute lorsque des événements sont déclenchés dans des contrôles d’interface utilisateur. | Des **gestionnaires d’événements** et **détecteurs d’événements** sont ajoutés dans le langage XML ou par programme. | Les contrôles envoient des messages d’**action** aux **cibles**. | Vous pouvez définir des méthodes pour gérer les événements d’un contrôle XAML dans un **fichier code-behind** attaché à la page XAML. Des **gestionnaires d’événements** sont toujours écrits dans le code. Toutefois, vous pouvez associer ces gestionnaires à des événements dans le balisage XAML ou le code.<br/><br/>[Ajouter des contrôles et gérer les événements](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[Vue d’ensemble des événements et des événements routés](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **Liaison de données.** Modèle de conception logicielle qui permet à l’interface utilisateur de votre application d’afficher des données et éventuellement de rester synchronisé avec celles-ci.  | Une **bibliothèque de liaison de données** est fournie, bien qu’elle soit toujours en version bêta. | Il n’existe aucun système de liaison intégré sur iOS. Il est possible de se baser sur **Key-value observing** pour effectuer des liaisons de données, soit par l’utilisation d’une bibliothèque tierce, ou l’écriture de code supplémentaire. Les contrôles utilisent une approche délégué/rappel pour l’obtention des données. | La plateforme UWP traite pour vous **la liaison de données**. Vous utilisez l’extension de balisage **[{x: Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)**  pour tirer parti de la liaison de données hautes performances ou **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)** pour exploiter d’autres fonctionnalités. Il suffit alors de configurer votre liaison pour choisir si la plateforme utilise  une **liaison à sens unique** pour afficher les valeurs provenant d’une source de données dans votre interface utilisateur, ou si elle observe ces valeurs et met à jour votre interface utilisateur lors du passage en **liaison bidirectionnelle**.<br/><br/>[Liaison de données](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **Automatisation de l’interface utilisateur.** Accès par programme aux éléments d’interface utilisateur, rendant les applications accessibles aux produits de technologie d’assistance et permettant aux scripts automatisés d’interagir avec votre interface utilisateur. | Les valeurs **Text labels**, **contentDescription** et **hint** permettent de garantir que les éléments d’interface utilisateur puissent être trouvés par le biais de l’automatisation. Android Studio vous permet d’écrire des tests d’interface utilisateur à l’aide des infrastructures de test **UI Automator** et **Espresso**. | L’**instrument d’automatisation** vous permet d’écrire des scripts de test d’interface utilisateur automatisés qui identifient les éléments à l’aide de paramètres d’**accessibilité** ou de la position de l’élément dans la **hiérarchie d’éléments**. | Vous obtenez un accès par programme aux éléments d’interface utilisateur intégrés dans UWP fournie avec **[UI Automation](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**.<br/>Les **[homologues d’automatisation personnalisés](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)** vous permettent de fournir la prise en charge de l’automatisation pour vos propres classes d’interface utilisateur personnalisées. Le **[projet de test codé de l’interface utilisateur](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)** dans Visual Studio vous permet de tester automatiquement l’ensemble de votre application par le biais de l’interface utilisateur ou de tester l’interface utilisateur de manière isolée. |
|  **Modification de l’apparence d’un contrôle.** Modification de la taille, de la couleur et d’autres attributs. | Les contrôles possèdent des **propriétés** qui peuvent être modifiées à l’aide de l’outil de conception, dans le balisage XML ou par programme. | Les contrôles possèdent des **attributs** que vous pouvez modifier à l’aide de l’**Attributes Inspector** dans Interface Builder ou par programme. | Vous pouvez modifier les **propriétés** des contrôles dans le balisage XAML ou par programme, à l’aide de Visual Studio et de Blend pour Visual Studio.<br/><br/>[Ajouter des contrôles et gérer les événements](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Styles visuels réutilisables.** Application de modifications visuelles à un certain nombre de contrôles, dans un format réutilisable. | Les **Styles XML** sont des ensembles de propriétés appliqués à un ou plusieurs contrôles. | iOS ne prend pas en charge les styles visuels réutilisables fournis, toutefois le protocole UIAppearance permet à plusieurs contrôles de partager des attributs communs. | Vous pouvez créer des **[styles](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)** réutilisables, qui peuvent être appliqués à plusieurs contrôles et stockés dans un **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** pour faciliter leur réutilisation.<br/><br/>[Démarrage rapide : application de styles aux contrôles (XAML)](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **Modification de la structure visuelle des contrôles.** Personnalisation de la structure visuelle d’un contrôle au-delà de la simple modification des propriétés ou des attributs, par exemple, déplacement d’un texte de case à cocher sous cette dernière. | Il n’existe aucune méthode de modification simple de la structure visuelle des contrôles dans Android. | Il n’existe aucune méthode de modification simple de la structure visuelle des contrôles dans iOS. | Pour personnaliser la structure visuelle d’un contrôle, vous pouvez copier et modifier son **[modèle de contrôle](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)** dans le balisage XAML.<br/><br/>[Démarrage rapide : modèles de contrôle (XAML)](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **Mouvements tactiles intégrés.** Prise en charge personnalisée de la fonctionnalité tactile par la gestion des événements de mouvement abstraits de niveau élevé, tels que l’appui et le double appui dans les vues et les contrôles. | Les **détecteurs de mouvement** détectent les mouvements tactiles de base, y compris le défilement, l’appui prolongé, et le glissement rapide. | L’infrastructure UIKit fournit des **outils de reconnaissance de mouvement** qui détectent les mouvements tactiles, tels que l’appui, le pincement, le mouvement panoramique, le balayage, la rotation et l’appui prolongé. | Les **éléments d’interface utilisateur** vous permettent de gérer les **événements de mouvement statique**, notamment l’appui, le double appui, l’appui droit et le maintien, ainsi que les **événements de mouvement de manipulation**, notamment le glissement, le balayage, la rotation, le pincement et l’étirement. Les événements de mouvement sont des **événements routés** et peuvent être gérés par des objets parent contenant l’élément d’interface utilisateur enfant.<br/><br/>[Interactions tactiles](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[Interactions utilisateur personnalisées (mouvements, manipulations et interactions)](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## Navigation et structure de l’application

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Dispositions.** La disposition définit la structure de l’interface utilisateur. | La disposition se compose de **groupes d’affichages**, tels que **LinearLayout** et **RelativeLayout** qui peuvent imbriquer d’autres groupes d’affichages ou vues. | La disposition est constituée d’un **UIViewController** contenant des **UIView** qui peuvent être imbriqués.  | XAML fournissant un système de disposition flexible composé de **classes de panneau de disposition**, telles que **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**, **[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**, **[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** et **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)** pour les dispositions statiques et réactives. Les **[propriétés](https://msdn.microsoft.com/library/ms171352.aspx)** permettent de contrôler la taille et la position des éléments.<br/><br/>[Définir des dispositions avec XAML](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **Navigation pair à pair.** Présentation à l’utilisateur de méthodes de navigation entre les pages d’importance hiérarchique équivalente. | Les **onglets**, **vues à balayage** et **panneaux de navigation** permettent une **navigation latérale**. | Les **contrôleurs de la barre d’onglets**, **les contrôleurs du mode fractionné** et les **contrôleurs d’affichage de page** permettent de naviguer entre les vues de hiérarchie équivalente. | Vous pouvez afficher une liste permanente de liens/onglets au-dessus du contenu à l’aide d’**[onglets/de pivots](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)**. Le **[mode fractionné/volet de navigation](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)** vous permet d’afficher une liste de liens avec le contenu.<br/><br/>[Navigation](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[Navigation pair à pair entre deux pages](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **Navigation hiérarchique.** Navigation entre les pages parent et enfant d’une hiérarchie. | Les **Listes**, **listes de quadrillage**, **boutons** et autres contrôles permettent une **navigation par descendants** lorsqu’ils sont utilisés dans l’**intention** de charger d’autres **activités**. | Les **contrôleurs de navigation** permettent aux utilisateurs de naviguer entre les niveaux d’une hiérarchie. | Les **[concentrateurs](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)** permettent de présenter à l’utilisateur un aperçu du contenu qui peut être sélectionné pour naviguer vers les pages enfant. **
            [Maître/détails](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)** permet aux utilisateurs de faire une sélection parmi une liste de résumés d’éléments qui s’affichent en regard de la section correspondante relative aux détails.<br/><br/>[Navigation](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **Navigation via le bouton Précédent.** Retour à une application. | Les boutons **précédent** et **haut** situés dans la barre d’actions permettent une navigation par **ancêtres** et **temporelle** à l’aide de la **pile Back**. | Le **contrôleur de navigation** peut se voir ajouter un bouton Précédent.<br/> | Vous pouvez facilement gérer les appuis sur les boutons matériels ou logiciels à l’aide de la **[propriété pile Back](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)** qui permet aux utilisateurs de traverser l’**historique de navigation**.<br/><br/>[Navigation via le bouton Précédent](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **Écran de démarrage.** Affiche d’une image au lancement de l’application, principalement utilisé pour la personnalisation. | Les écrans de démarrage ne sont pas fournis par défaut et sont implémentés en modifiant l’**arrière-plan du thème** des premières activités. | Les applications doivent disposer d’une **image de lancement statique** ou d’un **fichier de lancement XIB/de table de montage séquentiel**. | Vous créez un écran de démarrage à l’aide d’une **image** et d’un arrière-plan coloré. [Vous pouvez prolonger l’affichage de l’écran de démarrage](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx).<br/><br/>[Ajouter un écran de démarrage](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[Recommandations en matière d’écran de démarrage](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## Entrées personnalisées

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Voix.** Reconnaissance vocale pour la saisie vocale et fonctionnalités vocales supplémentaires. | La saisie vocale peut être assurée par toute application implémentant une classe **RecognizerIntent**, tel que la **recherche vocale Google**. La classe **SpeechRecognizer** permet aux applications d’utiliser l’API de reconnaissance vocale de Google. | Aucune reconnaissance vocale intégrée ou API de saisie vocale n’existe. | Vous pouvez utiliser l’API de **[reconnaissance vocale](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** pour interagir avec votre application au premier plan. Vous pouvez utiliser des **[interactions Cortana](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)** vocales pour lancer des applications au premier plan ou en arrière-plan et pour interagir avec des applications en arrière-plan.<br/><br/>[Interactions vocales](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **Entrées utilisateur personnalisées.** Gestion du clavier, de la souris, du stylet et d’autres entrées. | Prise en charge de l’interaction via la fonctionnalité **tactile**, le **pavé tactile**, le **stylet**, la **souris** et le **clavier**. Les mouvements et entrées sont considérés comme des mouvements tactiles, toutefois, il est possible de détecter plus d’informations concernant le **périphérique d’entrée**. | La prise en charge de la fonctionnalité **tactile**, de l’**Apple Pencil** et du **clavier** est assurée. | Vous découvrirez une prise en charge pour une large gamme d’interactions, notamment **[tactiles](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**, avec le **[pavé tactile](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**, le **[stylet](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)** avec entrée manuscrite, la **[souris](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)** et le **[clavier](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**. Vos applications peuvent gérer les données sans avoir besoin de savoir quel périphérique d’entrée a été utilisé, et les données de périphérique d’entrée brutes sont accessibles si nécessaire.<br/><br/>[Gérer les entrées du pointeur](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[Interactions utilisateur personnalisées](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## Données

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Données d’application locales.** Stockage local des paramètres et des fichiers associés à votre application. | Les fichiers locaux peuvent être enregistrés à l’aide de **openFileOutput** et **openFileInput**. Les paramètres d’un **fichier de préférences partagé** sont accessibles à l’aide de **getSharedPreferences**. | Les fichiers locaux peuvent être stockés dans le répertoire **prise en charge de l’application**, accessible via la classe **NSFileManager**. Les paramètres des fichiers de **preferences** sont accessibles via la classe **NSUserDefaults** par défaut. | Les classes **[Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** gèrent pour vous le stockage des données locales de manière uniformisée. Vous stockez les paramètres sous forme d’objet **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)**, accessible via la propriété **[ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)**. Vous stockez les fichiers sous forme d’objet **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)**, accessibles via la propriété **[ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)**.<br/><br/>[Stocker et récupérer des paramètres et autres données d’application](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **Stockage de base de données local.** Stockage des données d’application dans une base de données relationnelle, avec ORM, le cas échéant. | La base de données **SQLite** est fournie. Aucun ORM n’est intégré. Les requêtes SQL sont exécutées à l’aide de la classe **SQLiteDatabase**. | La base de données **SQLite** est fournie. **CoreData** constitue l’infrastructure graphique d’objet intégrée qui peut être utilisée avec SQLite et peut proposer des fonctionnalités comparables à un ORM. | Vous pouvez stocker des données à l’aide **SQLite**. **
            [Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)** est un ORM intégré qui permet d’éviter d’avoir recours à l’écriture d’une grande quantité de code d’accès aux données et permet d’interroger facilement la base de données sans écrire de code SQL. Vous pouvez exécuter des requêtes SQL directement avec la [bibliothèque SQLite](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx).<br/><br/>[Accès aux données](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx). |
|  **Bibliothèques HTTP pour l’accès à REST.** Bibliothèques intégrées qui vous permettent de communiquer avec les services web et les serveurs web à l’aide du protocole HTTP(S).<br/> | Bibliothèques HTTP **HttpURLConnection** et **Volley**. | **NSURLSession**, **NSURLConnection** et **NSURLDownload**. | Vous pouvez utiliser l’API **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** intégrée pour accéder à des fonctionnalités HTTP communes, y compris à GET, DELETE, PUT, POST, aux modèles d’authentification courants, à SSL, aux cookies et aux informations de progression. |
|  **Services de sauvegarde dans le cloud.** Services de sauvegarde fournis par la plate-forme pour les données d’application.  | Le **gestionnaire de sauvegarde** d’Android gère la sauvegarde des données d’application dans le **service de sauvegarde Android** de Google.  | La **sauvegarde sur iCloud** peut être configurée par un utilisateur pour gérer ses sauvegardes, y compris les données d’application. Les applications utilisant des **données principales** compatibles iCloud, le **magasin clé-valeur iCloud** et le **stockage de documents iCloud**. | Les données d’application que vous stockez à l’aide des **[API ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)** itinérantes **[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** et [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx)) seront automatiquement synchronisées sur le cloud et les autres appareils de l’utilisateur. La synchronisation s’effectue par le biais du compte Microsoft de l’utilisateur.<br/><br/>[Recommandations en matière de données d’application itinérantes](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **Téléchargements de fichiers sur HTTP.** Téléchargement de fichiers de petite et grande taille sur HTTP. | **URLConnection** et **HTTPURLConnection** sont utilisés pour effectuer des téléchargements sur HTTP et FTP. Il est également possible d’utiliser le **gestionnaire de téléchargement** système à télécharger en arrière-plan. | **NSURLSession** et **NSURLConnection** peuvent être utilisés pour télécharger des fichiers sur HTTP et FTP. | L’**[API de transfert en arrière-plan](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** vous permet de transférer de manière fiable des fichiers sur HTTP(S) et FTP en prenant en compte la suspension d’une application, la perte de connectivité et le réglage en fonction de l’autonomie de la batterie et de la connectivité. Vous pouvez également utiliser **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)** qui est idéal pour les fichiers de plus petite taille.<br/><br/>[Quelle technologie de réseau ?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Transferts en arrière-plan](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **Sockets.** Création de datagrammes UDP et de sockets TCP de faible niveau pour communiquer avec d’autres appareils à l’aide de votre propre protocole. | La classe **Socket** fournit des sockets TCP. La classe **DatagramSocket** fournit un socket UDP. | **NSStream** et **CFStream** fournissent des sockets TCP. **CFSocket** fournit des sockets UDP. | Vous pouvez utiliser la classe **[DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** pour communiquer à l’aide d’un socket de datagramme UDP et la classe **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** pour communiquer sur TCP ou Bluetooth RFCOMM.<br/><br/>[Notions de base en matière de réseau](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Quelle technologie de réseau ?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Vue d’ensemble de sockets](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets.** Assurer une communication bidirectionnelle entre un client et un serveur, ce qui permet le transfert de données en temps réel. | Aucune bibliothèque WebSockets intégrée n’existe sur Android. | Aucune bibliothèque WebSockets intégrée n’existe sur iOS. | Des connexions sécurisées aux serveurs prenant en charge WebSockets peuvent être mises en place à l’aide de la classe **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** pour les messages de plus petite taille avec des notifications de réception et **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)** pour les transferts de fichiers binaires de plus grande taille pouvant être lus en sections.<br/><br/>[Notions de base en matière de réseau](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Quelle technologie de réseau ?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Vue d’ensemble de WebSockets](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **Bibliothèques OAuth.** Bibliothèques OAuth permettant d’accéder à des fournisseurs OAuth tiers et à toute gestion de compte intégrée à la plateforme. | Aucune bibliothèque OAuth générique n’est fournie. La classe **GoogleAuthUtil** est fournie pour l’authentification OAuth avec les Services Google Play.<br/> | Aucune bibliothèque OAuth générique n’est fournie. L’**infrastructure des comptes** permet d’accéder aux comptes d’utilisateurs déjà stockés sur l’appareil, tels que Facebook et Twitter. | Le **[broker d’authentification Web](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)** de la bibliothèque OAuth générique permet de se connecter à des services de fournisseur d’identité tiers. Le **[stockage sécurisé des informations d’identification ](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)** permet aux utilisateurs d’enregistrer leurs informations de connexion et de les utiliser sur plusieurs appareils. L’espace de noms **[Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** vous permet d’accéder facilement à Live SDK OAuth pour l’accès aux services Microsoft.<br/><br/>[Authentification et identité des utilisateurs](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Documentation sur l’API Windows.Security.Authentication.Web](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[Exemple de code WebAuthenticationBroker](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## Outils

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE.** Ensemble d’outils utilisé pour créer votre application. | **Android Studio** et **Eclipse**, ainsi que Google incitent les développeurs à utiliser Android Studio. | **Xcode** | **
            [Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** et **[Blend pour Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** disposent de tout ce dont vous avez besoin pour coder, concevoir, connecter, déboguer, analyser, optimiser et tester les applications UWP. Visual Studio propose également des **[émulateurs](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)** pour les appareils Windows 10 afin de pouvoir tester votre application sur une large gamme d’appareils émulés.<br/><br/>[Téléchargements et outils pour UWP](https://dev.windows.com/downloads) |
|  **Organisation du code.** Structure de dossiers de base d’une application, souvent créée à partir d’un modèle d’origine. | Fichier **AndroidManifest**, dossier **java** contenant les fichiers sources, dossier **res** avec ressources comprenant des dispositions et des valeurs, scripts de création **Gradle** dans Android Studio et **Ant** dans Eclipse. | Fichiers sources et **fichiers de prise en charge**, fichier **Info.plist**, **Main.storyboard** et **LaunchScreen.storyboard**. Les images sont stockées dans les **bibliothèques de ressources**. | Votre application UWP contient des fichiers XAML et de code pour votre application intitulée Example.xaml et Example.xaml.cs, différentes images dans le **dossier de ressources**, une page de démarrage comme **MainPage.xaml** et **MainPage.xaml.cs** et un manifeste.<br/><br/>[Créer une application Hello World](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## Cycle de vie de l’application

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Cycle de vie de l’application.** Gestion des événements lors du lancement, de la suspension, de la reprise et de la fermeture d’une application permettant d’enregistrer/de restaurer l’état de l’application et d’exécuter d’autres tâches. | Chaque activité possède son propre **cycle de vie d’activité** avec des états de type **reprise**. Les **rappels de cycle de vie** tels que **onResume** sont implémentés dans vos **classes d’activité**. | Le **cycle de vie de l’application** peut avoir des états de type **suspendue**. Les méthodes telles que **applicationDidEnterBackground:** sont implémentées dans l’**objet délégué d’application** pour exécuter du code lors d’un changement d’état. | Votre application dispose des **états d’exécution** suivants : NotRunning, Activated, Running, Suspending, Suspended et Resuming.<br/><br/>Vous pouvez implémenter les méthodes de **[classe d’application](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)** OnLaunched, OnActivated, Suspending ou Resuming dans votre application afin d’exécuter du code lors d’un changement d’état.<br/><br/>[Cycle de vie de l’application](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **Tâches en arrière-plan.** Tâches qui effectuent des opérations en arrière-plan et qui continuent à s’exécuter lorsque l’application n’est plus au premier plan. | Les applications peuvent lancer des **services** qui effectuent des opérations en arrière-plan lorsque l’application n’est plus au premier plan. Les services ont leur propre **cycle de vie** et sont enregistrés dans le manifeste. | L’**exécution en arrière-plan** est autorisée uniquement pour les types de tâches spécifiques.<br/><br/>Les applications déclarent les **tâches en arrière-plan prises en charge** dans le fichier Info.plist à l’aide de **UIBackgroundModes**.<br/><br/>Le système contrôle l’exécution des tâches en arrière-plan et leur durée. | Vous pouvez créer une tâche en arrière-plan en implémentant l’interface **[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** et en inscrivant la tâche dans le manifeste de l’application. Vous pouvez définir une tâche à déclencher avec un [**minuteur**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx), un [**déclencheur système**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx), et un [**déclencheur de maintenance**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx).<br/><br/>[Prendre en charge votre application avec des tâches en arrière-plan](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[Créer et inscrire une tâche en arrière-plan](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[Recommandations pour les tâches en arrière-plan](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## Performances

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Meilleures pratiques en matière de performances** Recommandations en matière de création d’applications rapides, réactives, préservant l’autonomie de la batterie et offrant un démarrage rapide. | Android fournit le guide de formation **Meilleures pratiques en matière de performances**. | iOS fournit le document **Vue d’ensemble des performances**. | Vous pouvez lire le **[guide des performances](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)** détaillé comprenant des sections traitant de sujets, tels que la définition d’objectifs en matière de performances, la mesure des performances, la gestion de la mémoire, la fluidité des animations, l’accès efficace au système de fichiers et les outils disponibles pour le profilage et les performances. |
|  **Optimisation de la vue pour une interface utilisateur réactive.** Amélioration des performances par l’optimisation des vues. | L’optimisation des **hiérarchies de disposition** à l’aide de l’outil Visionneuse de la hiérarchie, la **réutilisation des dispositions** et le chargement des **vues à la demande**, sont des techniques qui permettent d’assurer la réactivité du thread et d’éviter les boîtes de dialogue « L’application ne répond pas » (**ANR**).<br/> | La résolution des problèmes liés à l’interface utilisateur avec le **rendu hors écran**, le **mélange des couches** et la **rastérisation** à l’aide de l’outil **Core Animation** assure la réactivité du thread de l’interface utilisateur. | Vous pouvez facilement **optimiser** le **balisage** et les **dispositions** XAML en suivant quelques étapes simples. Les techniques incluent la réduction de la structure de la disposition, du nombre d’éléments et du surdessin. <br/><br/>[Assurer la réactivité du thread de l’interface utilisateur](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[Optimiser votre balisage XAML](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[Optimiser votre disposition XAML](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **Threads.** Utilisation de threads pour assurer la **réactivité de l’interface utilisateur ** et exécuter plusieurs **tâches en parallèle**. | Les threads sont obtenus à l’aide des classes **Runnable**, **Handler**, **ThreadPoolExecutor**, et **AsyncTask** de niveau supérieur. | Les threads sont obtenus à l’aide des classes **NSThread**, **Grand Central Dispatch** et **NSOperation** de niveau supérieur. | Vous pouvez travailler avec des threads en soumettant des **éléments de travail** au **pool de threads** avec **[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)**. Vous pouvez utiliser un minuteur pour envoyer un élément de travail avec **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)** et créer un élément de travail qui se répète avec **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)**.<br/><br/>[Envoyer un élément de travail au pool de threads](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[Utiliser un minuteur pour envoyer un élément de travail](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[Créer un élément de travail périodique](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[Meilleures pratiques pour l’utilisation du pool de threads](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **Programmation asynchrone.** Éviter la complexité des threads en tirant parti des modèles de programmation asynchrones pour garantir la réactivité du thread de l’interface utilisateur.  | L’utilisation des **threads est requis** pour créer vos propres classes asynchrones. Certaines classes intégrées sont asynchrones. | L’utilisation des **threads est requis** pour créer vos propres classes asynchrones. Certaines classes intégrées sont asynchrones. | Vous pouvez utiliser les modèles asynchrones pour éviter le blocage du thread principal lorsque vous créez vos propres API, par exemple, à l’aide de **async** et **await** en C# et Visual Basic. Vous pouvez utiliser les API asynchrones intégrées qui se terminent par le mot **Async**.<br/><br/>[Programmation asynchrone](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[Appeler des API asynchrones en C# ou Visual Basic](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **Optimisation de l’affichage Liste.** Modèles intégrés permettant d’optimiser des listes de données, qui sont souvent peu performantes pour l’affichage de grandes quantités de données | Le modèle de conception **ViewHolder** est utilisé pour éviter les multiples recherches de vues, et vous permet d’utiliser des éléments d’interface utilisateur réutilisables. | Diverses optimisations peuvent être effectuées pour améliorer les performances de **UITableView**. Rien n’est intégré. | Vous pouvez utiliser les contrôles [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) et [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) qui assurent la **virtualisation de l’interface utilisateur** offrant un mouvement panoramique fluide, une expérience de défilement expérience et un démarrage plus rapide. Vous pouvez également implémenter [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) et [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx) dans votre source de données, pour **virtualiser les données** et améliorer les performances.<br/><br/>[Optimisation des options d’interface ListView et GridView](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[Virtualisation des données ListView et GridView](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## Monétisation

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Achats dans l’application.** Fonctionnalités de la plateforme permettant aux utilisateurs d’effectuer des achats dans vos applications. | La **facturation dans l’application** est fournie par les services Google. Les produits sont ajoutés à la **Console développeur de Google Play**. Les achats dans l’application sont implémentés à l’aide de la **bibliothèque de facturation Google Play**. | Les produits sont ajoutés à **iTunes Connect**. Les achats dans l’application sont implémentés à l’aide de l’infrastructure **StoreKit**.<br/><br/>Les produits sont achetés à l’aide de **SKMutablePayment** et **SKPaymentQueue**. | Vous créez des achats de produits in-app pour votre application en les[ ajoutant à votre application et les soumettant au Windows Store](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx). <br/><br/>Vous utilisez la **[classe CurrentApp](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)** pour définir des achats dans l’application. <br/><br/>Vous utilisez **[CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)** pour afficher l’interface utilisateur qui permet aux clients d’acheter le produit.<br/><br/>[Activer les achats de produits dans l’application](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **Achats de consommables dans l’application.** Produits intégrés à l’application pouvant être achetés, utilisés, puis de nouveau achetés. | Les achats de consommables sont activés par un achat régulier, puis sa consommation à l’aide de **consumePurchase**, qui lui permet d’être acheté, utilisé, puis acheté de nouveau. | Les produits consommables sont **définis sous forme de produits consommables** dans iTunes Connect. | Vous pouvez prendre en charge des consommables en [définissant leur type de produit sur Consommable lorsque vous les envoyez au](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx) Windows Store. Vous devez ensuite appeler **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)** après l’achat d’un produit pour permettre au client d’y accéder.<br/><br/>[Activer les achats de consommables dans l’application](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **Test des achats dans l’application.** Permet de tester le code d’achat dans l’application sans placer votre application dans le Windows Store. | Le **bac à sable de facturation dans l’application** est utilisé pour le test.  | Les **comptes de testeur de bac à sable (sandbox)** sont utilisés pour le test. | Vous pouvez tester des achats dans l’application en utilisant simplement la classe **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** au lieu de CurrentApp.<br/><br/> |
|  **Essais gratuits.** Permet de limiter facilement le contenu ou de supprimer des publicités en fonction de la version d’évaluation d’une application. | Google Play **ne prend pas en charge officiellement les versions d’évaluation**. Les essais gratuits ou la suppression des publicités s’obtient en créant un achat dans l’application et en prenant le chemin d’accès au code approprié lors de la confirmation de la réussite de l’achat. | L’App Store **ne prend pas en charge officiellement les essais gratuits d’applications**. Les essais gratuits ou la suppression des publicités s’obtient en créant un achat dans l’application et en prenant le chemin d’accès au code approprié lors de la confirmation de la réussite de l’achat. | Vous pouvez proposer une version d’évaluation gratuite de votre application à l’aide de l’**[option Essai gratuit](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)** lors de l’envoi de votre application au Windows Store. Vous pouvez ensuite utiliser **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** pour vérifier l’état d’essai de l’application et présenter, par conséquent, les différents chemins d’accès au code. Vous pouvez vous inscrire à l’[événement LicenseChanged](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged) pour être averti lorsque l’utilisateur modifie l’état de l’essai lors de l’exécution de l’application.<br/><br/>[Exclure ou limiter des fonctionnalités de la version d’évaluation](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## Adaptation aux différentes plateformes

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Interface utilisateur adaptative : dispositions flexibles.** Prise en charge de différentes tailles d’écran avec une hauteur et une largeur flexibles. | Des dispositions flexibles peuvent être obtenues à l’aide des valeurs **wrap_content** et **match_parent** des objets LinearLayout, ou en utilisant des objets RelativeLayout pour l’alignement. | Des dispositions flexibles peuvent être obtenues à l’aide du **modèle adaptatif** avec des tables de montage séquentiel universelles, en utilisant la **Disposition automatique** avec des **contraintes** et des **caractéristiques** telles que horizontalSizeClass et displayScale qui sont appliquées aux contrôleurs d’affichage. | Vous pouvez créer une disposition fluide à l’aide de **propriétés** et de **panneaux de disposition** avec une combinaison de dimensionnement fixe et dynamique.<br/><br/>[Définir des dispositions avec XAML - Propriétés et panneaux de disposition](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[Conception dynamique 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Interface utilisateur adaptative : dispositions adaptées.** Prise en charge de différentes tailles d’écran avec des dispositions ciblées distinctes. | Le fait de fournir d’autres fichiers de disposition pour différentes configurations d’écran dans le répertoire de ressources utilisant des **qualificateurs de configuration** tels que **small**, **large**, **ldpi**, et **hdpi** vous permet de cibler des dispositions personnalisées pour les écrans de différentes tailles et densités. | Définissez une **table de montage séquentiel pour iPhone et iPad distincte** afin d’adapter les dispositions à différentes familles d’appareils dans une application universelle. | Vous pouvez créer une disposition personnalisée en définissant **différents fichiers de balisage XAML** par famille d’appareils.<br/><br/>[Définir des dispositions avec XAML - Dispositions personnalisées](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **Interface utilisateur adaptative : dispositions dynamiques.** Réponse aux changements de taille d’écran, par exemple, à la rotation, ou à une modification de la taille d’une fenêtre. | L’utilisation de dispositions flexibles avec **LinearLayout** et **RelativeLayout**, ou le fait de proposer d’autres fichiers de disposition pour différentes orientations offre des dispositions dynamiques. | Lors du changement de la **taille** ou des **caractéristiques** d’une vue, les **contraintes** spécifiées dans les tables de montage séquentiel s’appliquent. | Vous pouvez facilement réorganiser, repositionner, redimensionner, faire apparaître ou remplacer des sections de votre interface utilisateur lors de l’exécution en réponse aux changements de taille de fenêtre à l’aide de **[VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**, **[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** et **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)**.<br/><br/>[Définir des dispositions avec XAML - États visuels et déclencheurs d’état](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[Conception dynamique 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Prise en charge de différentes fonctionnalités d’appareils.** Exploitation des fonctionnalités matérielles avancées tout en assurant la prise en charge des appareils qui n’en sont pas dotés. | Le fait de tester des fonctionnalités d’appareil au moment de l’exécution à l’aide de **PackageManager.hasSystemFeature** vous permet de déterminer si un code spécifique d’un matériel peut s’exécuter. | Il n’existe **aucune vérification unique** à effectuer lors de l’exécution pour tester les fonctionnalités d’un appareil. Chaque fonctionnalité est testée de manière spécifique pour déterminer si le code propre à un matériel peut être exécuté. | Vous pouvez ajouter des **Kits de développement logiciel (SDK) d’extension de plate-forme** à votre package pour cibler les fonctionnalités supplémentaires trouvées dans différentes familles d’appareils : téléphone, ordinateur de bureau et IoT. Vous utilisez l’**[ApiInformation](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** pour vérifier la présence de types et de membres lors de l’exécution. Vous ne pouvez appeler ces types et membres que s’ils sont présents. |
|  **Prise en charge de différentes fonctionnalités d’appareils.** Exploitation des fonctionnalités matérielles avancées tout en assurant la prise en charge des appareils qui n’en sont pas dotés. | La **bibliothèque de prise en charge Android** peut être fournie avec votre application afin de mettre à disposition quelques nouvelles API aux utilisateurs d’anciennes versions d’Android. Le test du niveau d’API lors de l’exécution peut être effectué à l’aide de **Build.Version.SDK_INT**. | Les vérifications à l’exécution standard permettent de déterminer si des API sont disponibles, comme la méthode **class** qui vérifie l’existence d’une classe et **respondsToSelector :** qui recherche les méthodes sur les classes.  | Vous pouvez utiliser **[ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** pour vérifier la présence d’un contrat API avec un nombre majeur et mineur spécifié. Vous utilisez également l’**[API ApiInformation](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** pour tester la présence de types et de membres lors de l’exécution. Vous ne pouvez appeler ces types et membres que s’ils sont présents. |

## Notifications

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Vignettes et badges.** Présentation des mises à jour aux utilisateurs sur l’écran d’accueil. | Les **widgets d’application** sont des vues de votre application qui peuvent être intégrées à l’écran d’accueil et recevoir des mises à jour périodiques. Il n’existe **aucun système de badge** sur Android. Il n’existe aucun système identique aux vignettes. | Il n’existe **aucune vignette ou aucun widget** sur iOS. Vous pouvez ajouter un **badge** à votre icône avec un nombre qui peut changer suite à des notifications locales ou distantes. | Votre application dispose d’une **vignette** qui peut être épinglée à l’écran de démarrage et permet d’afficher les textes, images et un **badge** de votre choix avec des glyphes et des chiffres. Vous pouvez mettre à jour le contenu des vignettes à partir de l’application par le biais de notifications Push ou selon un calendrier prédéfini. Les vignettes peuvent être adaptatives et varier en fonction de l’endroit où elles sont affichées.<br/><br/>[Créer des vignettes](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[Créer des vignettes adaptatives](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[Choisir une méthode de remise de notification](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Recommandations en matière de vignettes et de badges](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **Affichage des notifications.** Types de notifications pouvant être affichées. | Les notifications peuvent être affichées dans la **zone de notification** et le **panneau de notification**. Les **notifications d’avertissement** s’affichent dans une petite fenêtre flottante. La définition d’un **PendingIntent** permet d’ajouter des actions aux notifications. | Les notifications contextuelles apparaissent sous forme de **bannières** ou d’**alertes**. Vous pouvez ajouter des boutons d’action personnalisés aux **notifications interactives** définis avec **UIMutableUserNotificationAction**. | Vous pouvez créer des notifications contextuelles adaptatives appelées **notifications toast**. Vous pouvez définir des notifications toast en XML avec du contenu visuel, des **actions** qui peuvent être des boutons, ou des entrées et du son.<br/><br/>[Notifications toast adaptatives et interactives](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Choisir une méthode de remise de notification](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Recommandations en matière de notifications toast](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **Planification de notifications locales.** Notifications locales envoyées par votre application à une heure prévue. | Les notifications et actions sont définies en utilisant à l’aide d’un **NotificationCompat.Builder** et peuvent être planifiées et gérés dans l’application à l’aide d’**AlarmManager** et de **BroadcastReceiver**. | Les notifications locales sont créées à l’aide de **UILocalNotification**, et peuvent être planifiées avec ** UILocalNotification.scheduleLocalNotification:**. | Vous pouvez planifier une notification toast à l’aide de **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)**. Vous pouvez envoyer une notification par vignette à partir de votre application en utilisant la **[classe TileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)**, ou planifier une notification par vignette avec [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx).<br/><br/>[Notifications toast adaptatives et interactives](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Envoyer une notification par vignette locale](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **Envoi de notifications Push.** Notification envoyée à partir d’un serveur de notification Push et éventuellement gérée dans l’application. | **Google Cloud Messaging** prend en charge les notifications Push pour Android. | Les notifications Push ou distantes sont fournies par le **service de notifications Push Apple**. | Vous recevez des notifications Push envoyées depuis les **Services de notifications Push Windows (WNS)** qui peuvent être de type vignette, toast, badge ou notification brute. Votre application peut utiliser l’événement de remise de notification [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) pour recevoir des notifications lorsque l’application est en cours d’exécution.<br/><br/>[Vue d’ensemble des services de notifications Push Windows (WNS)](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[Vue d’ensemble des notifications brutes](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## Capture et rendu multimédia

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Capture multimédia.** Enregistrement d’un contenu audio et visuel. | L’utilisation de **intent**, tel que MediaStore.ACTION_VIDEO_CAPTURE permet la capture multimédia avec une application de caméra existante. L’utilisation de la bibliothèque **android.hardware.camera2** ou **camera** permet d’implémenter une interface de caméra personnalisée. Les API **MediaRecorder** permettent de capturer des données audio. | **UIImagePickerController** permet la capture de vidéos et de photos avec l’interface utilisateur du système. Les classes **AVFoundation** telles que **AVCaptureSession** permettent d’accéder directement à la caméra. <br/>La classe **AVAudioRecorder** permet d’enregistrer du son. | Vous pouvez capturer des photos et des vidéos tout en utilisant l’interface utilisateur de la caméra intégrée avec la classe **[CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**. Vous pouvez interagir avec la caméra à un niveau faible et capturer du son à l’aide de classes dans **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)**, comme l’**[API MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)**. <br/><br/>[Capturer des photos et des vidéos à l’aide de CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[Capturer des photos et des vidéos à l’aide de MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **Lecture de contenu multimédia.** Lecture de fichiers audio et vidéo. | Les classes **MediaPlayer** et **AudioManager** permettent de lire des fichiers audio et vidéo. | L’**infrastructure AVKit**, **AVAudioPlayer**, et l’**infrastructure du lecteur multimédia** permettent de lire des fichiers audio et vidéo. | Vous pouvez utiliser les classes **[MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**, **[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)**, et **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** pour lire du contenu audio et vidéo à partir de sources telles que des fichiers locaux et distants.<br/><br/>[Lecture de contenu multimédia avec MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **Modification multimédia.** Composition de nouveaux fichiers multimédias à partir d’enregistrements existants et application d’effets spéciaux. | Les classes de faible niveau, telles que **MediaCodec**, **MediaMuxer**, et **android.media.effect** peuvent être utilisées pour modifier du contenu. | Les classes de l’infrastructure **AV Foundation**, telles que **AVMutableComposition**, **AVMutableVideoComposition**, et **AVMutableAudioMix** peuvent être utilisées pour modifier du contenu. | Vous pouvez utiliser les API **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)**, telles que **[MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** et **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)** pour créer des compositions multimédias à partir de fichiers audio et vidéo. Vous pouvez ajouter des superpositions d’images et de vidéos, combiner des clips vidéo, ajouter du son en arrière-plan et appliquer des effets audio et vidéo.<br/><br/>[Compositions multimédias et modification](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## Capteurs

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Capteurs.** Détection des propriétés environnementales, de position et de mouvement de l’appareil. | L’**infrastructure de capteur** permet d’accéder aux capteurs matériels et logiciels avec des classes, telles que **SensorManager** et **SensorEvent**.  | L’**infrastructure Core Motion** permet d’accéder aux données des capteurs bruts et traités. | Vous pouvez utiliser des classes dans **[Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** pour accéder aux mesures des capteurs et aux événements déclenchés lors de la réception de nouvelles données de lecture provenant de l’appareil.<br/><br/>[Capteurs](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## Localisation et mappage

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Localisation.** Recherche de l’emplacement **actuel** de l’appareil et suivi des **modifications**. | Les API de localisation des services Google Play offrent un accès de haut niveau au **dernier emplacement connu** avec le **fournisseur de localisation fusionné** à l’aide des méthodes **getLastLocation** et **requestLocationUpdates**. **LocationManager** offre un accès de bas niveau dans les bibliothèques Android. | La classe **CLLocationManager** de **Core Location** permet de surveiller l’emplacement d’un appareil, avec **startUpdatingLocation** pour le service de localisation standard et **startMonitoringSignificantLocationChanges** pour le service de localisation en cas de **changement notable**. | Vous pouvez suivre la localisation de l’appareil à l’aide des classes dans **[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)**. Utilisez **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)** pour une lecture unique. Utilisez **[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)** pour procéder à une localisation régulière à l’aide d’un minuteur ou être informé lorsque l’emplacement a changé.<br/><br/>[Obtenir l’emplacement de l’utilisateur](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **Affichage de cartes.** Affichage d’une **carte interactive intégrée** et ajout de **centres d’intérêt**. | Les classes **GoogleMap**, **MapFragment**, et **MapView** classes de l’**API Google Maps Android** permet d’intégrer des cartes dans des applications. Il est possible d’afficher des centres d’intérêt à l’aide de **marqueurs** et de la classe **Marker** personnalisable. | Les cartes sont intégrées aux applications iOS à l’aide de la classe **MKMapView** de l’**infrastructure MapKit**. Des **annotations** peuvent être ajoutées aux applications pour afficher des centres d’intérêt à l’aide de classes d’objet, telles que **MKPointAnnotation** et de classes de vue, telles que **MKPinAnnotationView**. | Vous pouvez intégrer des cartes dans vos applications à l’aide du contrôle XAML **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)** intégré qui fournit des vues 2D, 3D et Streeside. Vous pouvez ajouter des clics-infos, des images ou des formes aux centres d’intérêt à l’aide de classes, telles que **[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**, **[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** et **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)**.<br/><br/>[Afficher des cartes avec des vues 2D, 3D et Streetside](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[Afficher des centres d’intérêt sur une carte](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **Géorepérage.** Surveillance de l’entrée et de la sortie d’une région géographique particulière. | Les limites géographiques sont surveillées à l’aide des **services de localisation** du Kit de développement logiciel (SDK) des services Google Play. | Les régions sont surveillées avec la classe **CLCircularRegion** et enregistrées à l’aide de **CLLocationManager.startMonitoringForRegion:**. | Vous pouvez créer une limite géographique à l’aide de la classe **[Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** et définir les **états surveillés**, relatifs par exemple, à l’entrée ou à la sortie d’une région. Gérez les événements de limite géographique au premier plan avec la **[classe GeofenceMonitor](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)**, et en arrière-plan avec **[LocationTrigger](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**.<br/><br/>[Configurer une limite géographique](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **Géocodage et géocodage inverse.** Conversion d’adresses en emplacements géographiques (géocodage) et inversement (géocodage inverse).<br/> | La classe **Geocoder** est utilisée pour le géocodage et le géocodage inverse. | La classe **CLGeocoder** est utilisée pour le géocodage. | Vous pouvez effectuer le géocodage à l’aide de la **[classe MapLocationFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)** dans **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Utilisez **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)** pour le géocodage et **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)** pour le géocodage inverse.<br/><br/>[Effectuer un géocodage et un géocodage inverse](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **Indications et itinéraires.** Itinéraires, indications et distances entre deux emplacements géographiques. | Google propose l’**API Google Maps Directions** du service web qui peut être utilisée sur Android même si aucun Kit de développement logiciel n’est fourni. | Map Kit fournit l’API **MKDirections** qui peut être utilisée pour récupérer des informations relatives à un itinéraire et des indications. | Vous pouvez demander un itinéraire en voiture ou à pied avec la **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** de classe dans **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Les indications sont renvoyées sous forme d’instance **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)** qui peut être facilement affichée sur un MapControl. Les itinéraires sont renvoyés à l’intérieur de l’objet **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)**.<br/><br/>[Afficher des itinéraires et indications sur une carte](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## Communication entre les applications

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Appel d’une autre application.** Lancement d’une autre application et éventuellement partage de données, telles que des liens, du texte, des photos, des vidéos et des fichiers. | Une **intention implicite** permet de lancer une autre application en définissant une **action** et des données facultatives dans une **intention** et en l’appelant avec **startActivityForResult**.<br/> | Les **extensions d’application** permettent d’accéder aux données d’une autre application. Les **schémas d’URL** permettent de transmettre une URL à une autre application. | Vous pouvez lancer une autre application enregistrée pour un URI avec **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)**, ou **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** pour obtenir des résultats et des données à partir de l’application lancée. Vous pouvez utiliser **[Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)** pour transmettre un fichier à une autre application à gérer.<br/><br/>Vous pouvez utiliser un **contrat de partage** pour partager facilement des données entre des applications.<br/><br/>[Lancer l’application par défaut pour un URI](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[Lancer une application pour obtenir des résultats](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Lancer l’application par défaut d’un fichier](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[Partager des données](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **Autoriser l’appel de votre application.** Autorisation de votre application à répondre à une demande issue d’une autre application. | Les applications enregistrent une **activité de gestion d’intention** avec un **filtre d’intention** pour répondre à une intention implicite à partir d’une autre application. | La création d’un package d’une **extension d’application** permet de partager des données avec d’autres applications. Les applications peuvent enregistrer un **schéma d’URL personnalisé** à l’aide de la clé  **CFBundleURLTypes** d’Info.plist. | Vous pouvez enregistrer votre application comme gestionnaire par défaut d’un **nom de schéma d’URI** en enregistrant un **[protocole](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)** dans le manifeste du package et en mettant à jour le gestionnaire d’événements **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)**, qui renvoie éventuellement des résultats. De la même manière, vous pouvez enregistrer votre application comme gestionnaire par défaut pour certains types de fichiers en ajoutant une déclaration dans le manifeste du package et en gérant l’événement **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)**.<br/><br/>Vous pouvez gérer les demandes de contrat de partage en enregistrant votre application en tant que cible de partage dans le manifeste et en gérant l’événement **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)**.<br/><br/>[Lancer une application pour obtenir des résultats](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Gérer l’activation des fichiers](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[Recevoir des données](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **Copier-coller.** Copie et collage de texte et d’autres contenus entre les applications. | L’**infrastructure du Presse-papiers** peut servir à implémenter la fonction de copier-coller à l’aide des classes **ClipboardManager** et **ClipData**. | **UIPasteboard**, **UIMenuController**, et **UIResponderStandardEditActions** peuvent servir à implémenter la fonction de copier-coller. | De nombreux contrôles XAML par défaut prennent déjà en charge la fonction de copier-coller. Vous pouvez implémenter la fonction de copier-coller vous-même à l’aide des classes **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** et **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** dans **[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)**.<br/><br/>[Copier-coller](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **Glisser-déplacer.** Glisser-déplacer du contenu entre plusieurs applications. | La fonction de glisser-déplacer peut être implémentée au sein d’une seule application à l’aide de l’**infrastructure de glisser-déplacer Android**. | Aucune API de glisser-déplacer de haut niveau n’est fournie par iOS. | Vous pouvez implémenter la fonction de glisser-déplacer dans votre application pour permettre de glisser-déplacer du contenu d’une application à une autre, du Bureau vers une application et inversement. La prise en charge de la fonction de glisser-déplacer au sein de la classe UIElement s’effectue à l’aide des propriétés **[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)**, et **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)** et des événements **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)**, et **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)**.<br/><br/>[Glisser-déplacer](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## Conception de logiciels

|  **Concept général** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Modèles de conception de logiciels.** Modèles recommandés ou bien adaptés pour la plateforme. | Aucun modèle officiel n’a été recommandé ou fourni pour le développement Android, bien que la version bêta de l’infrastructure de liaison de données puisse permettre une utilisation plus généralisée du modèle **Model-View-ViewModel (MVVM)**. Un certain nombre d’articles et d’infrastructures tiers recommandent les approches **Model-View-Presenter (MVP)** et **MVVM**. | **Model-View-Controller (MVC)** est un modèle commun utilisé avec iOS et intégré à la plateforme. | Vous n’êtes pas limité à un modèle spécifique lorsque vous créez des logiciels pour UWP.<br/><br/>Vous pouvez utiliser le modèle de [liaison de données](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) intégré pour garantir une séparation nette des problèmes liés aux données et de ceux liés à l’interface utilisateur et éviter d’avoir à coder les gestionnaires d’événements de l’interface utilisateur qui mettent ensuite à jour les valeurs des propriétés.<br/><br/>Vous pouvez étendre la liaison de données de manière à suivre le modèle **Model-View-ViewModel (MVVM)** soit en utilisant des bibliothèques MVVM tierces, telles que le [Kit de ressources MVVM Light](https://mvvmlight.codeplex.com/), ou en déployant votre propre liaison et en maintenant la logique en dehors de code-behind.<br/><br/>[Le modèle MVVM](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[Modèles de projet Visual Studio Template 10](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


